(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{"2iqK":function(e,n,t){"use strict";t.d(n,"l",(function(){return d})),t.d(n,"h",(function(){return c})),t.d(n,"j",(function(){return p})),t.d(n,"c",(function(){return u})),t.d(n,"b",(function(){return f})),t.d(n,"a",(function(){return h})),t.d(n,"e",(function(){return m})),t.d(n,"k",(function(){return g})),t.d(n,"d",(function(){return b})),t.d(n,"g",(function(){return v})),t.d(n,"m",(function(){return y})),t.d(n,"n",(function(){return S})),t.d(n,"i",(function(){return L})),t.d(n,"f",(function(){return k}));t("rGqo");var i=t("lSNA"),o=t.n(i),r=t("9l/z"),a=t("Wgjw");function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n,t){return!n&&!t||!(n&&!e.startsWith(n+"\n")||t&&!e.endsWith("\n"+t))}function c(e,n,t){const i={head:!1,tail:!1};return n||t?(n&&!e.startsWith(n+"\n")&&(i.head=!0),t&&!e.endsWith("\n"+t)&&(i.tail=!0),i):i}function p(e,n,t){const i={head:!1,tail:!1};return"string"==typeof n&&n.trim()&&!e.startsWith(n)&&(i.head=!0),"string"==typeof t&&t.trim()&&!e.endsWith(t)&&(i.tail=!0),i}function u(e,n,t){let i=n;return i.trim()&&i.startsWith("\n")||""===e||(i="\n\n"+i),i.endsWith("\n")||""===t||(i+="\n\n"),`${e}${i}${t}`}const f=function(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];return n.reduce((e,n)=>function(){return e(n(...arguments))},e=>e)};function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:r.default;if(!e)return n;const t={};return e.languages.forEach(i=>{const o="string"==typeof e.lang_template[i]?e.lang_template[i]:"";let r="string"==typeof e.lang_head_template[i]?e.lang_head_template[i]:"",a="string"==typeof e.lang_tail_template[i]?e.lang_tail_template[i]:"";r.trim()||(r=""),a.trim()||(a="");const s=!(r||a||o);t[i]=Object.assign({},n[i],{headEnd:r,tailStart:a},(!s||e.isReadonlyEditable)&&{defaultText:o})}),t}function m(e){return e.displayName||e.name||"Component"}function g(e){return a.h[e]||""}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.value,t=arguments.length>1?arguments[1]:void 0,i=arguments.length>2?arguments[2]:void 0;const o=r.LSP_LANGUAGES.filter(e=>!i.includes(e));return o.includes(n)?t?a.d.LOADING:a.d.DISABLED:a.d.NOT_SUPPORTED}function v(e,n){let t;switch(n.event){case a.c.READY:t=a.d.READY;break;case a.c.ERROR:case a.g.ERROR:t=a.d.ERROR;break;case a.c.CLOSE:t=a.d.LOADING}return t}function y(e){let n=e.client,t=e.method,i=e.handler;const o=n[t];n[t]=i(n,o)}function S(e,n){["info","warn","error","logTrace"].forEach(t=>{e[t]=e=>{n&&n(t,e)}})}function L(e){if(e){return a.e.map(n=>{const t=e("editor."+n.label,n.label),i=n.items.map(t=>l({},t,{label:e(`editor.${n.id}.${t.label}`,t.label)}));return l({},n,{items:i,label:t})})}return a.e}const E={autocompleteAvailableText:"Autocomplete available for"};function k(e,n){return E[e]?n?n("editor."+e,E[e]):E[e]:""}},"2sXX":function(e,n,t){},"7Iy7":function(e,n,t){},"9l/z":function(e,n,t){"use strict";t.r(n),t.d(n,"LANGUAGE_OPTIONS",(function(){return i})),t.d(n,"LSP_LANGUAGES",(function(){return o}));t("rGqo");const i={c:{mime:"text/x-csrc",label:"C",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n",suffix:"clang",langId:1,lsp:"c",extension:"c"},cpp:{mime:"text/x-c++src",label:"C++",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    return 0;\n}\n",suffix:"clang",langId:2,lsp:"cpp",extension:"cpp"},java:{mime:"text/x-java",label:"Java 7",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",suffix:"java",langId:3,lsp:"java",extension:"java"},csharp:{mime:"text/x-csharp",label:"C#",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"using System;\nusing System.Collections.Generic;\nusing System.IO;\nclass Solution {\n    static void Main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution */\n    }\n}",suffix:"csharp",langId:9,lsp:"csharp",extension:"cs"},haskell:{mime:"text/x-haskell",label:"Haskell",headEnd:"-- Head ends here",tailStart:"-- Tail starts here",fold:"indent",defaultText:"-- Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:12,extension:"hs"},php:{mime:"text/x-php",label:"PHP",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:'<?php\n$_fp = fopen("php://stdin", "r");\n/* Enter your code here. Read input from STDIN. Print output to STDOUT */\n\n?>',suffix:"php",langId:7,lsp:"php",extension:"php"},python:{mime:"text/x-python",label:"Python 2",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"python",langId:5,lsp:"python",extension:"py"},perl:{mime:"text/x-perl",label:"Perl",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"brace",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:6,extension:"pl"},ruby:{mime:"text/x-ruby",label:"Ruby",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"ruby",langId:8,extension:"rb",lsp:"ruby"},bash:{mime:"text/x-sh",label:"BASH",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"brace",defaultText:"",suffix:"",langId:14,extension:"sh",syntax:"shell",lsp:"bash"},oracle:{mime:"text/x-plsql",label:"Oracle",fold:"indent",defaultText:"",suffix:"",langId:11,extension:"sql",syntax:"sql",headEnd:"",tailStart:""},mysql:{mime:"text/x-plsql",label:"MySQL",fold:"indent",defaultText:"",suffix:"",langId:10,extension:"sql",headEnd:"",tailStart:""},sql:{mime:"text/x-plsql",label:"SQL",fold:"indent",defaultText:"",suffix:"",syntax:"mysql",extension:"sql",headEnd:"",tailStart:""},clojure:{mime:"text/x-scheme",label:"Clojure",headEnd:"; Head ends here",tailStart:"; Tail starts here",fold:"indent",defaultText:"; Enter your code here. Read input from STDIN. Print output to STDOUT\n;",suffix:"",langId:13,extension:"clj"},scala:{mime:"text/x-scala",label:"Scala",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"object Solution {\n\n    def main(args: Array[String]) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution\n*/\n    }\n}",suffix:"",langId:15,extension:"scala"},code:{mime:"text/plain",label:"Generic",fold:"brace",suffix:"",extension:"txt",defaultText:"",headEnd:"",tailStart:""},text:{mime:"text/plain",label:"Plain Text",fold:"indent",defaultText:"",suffix:"",langId:28,extension:"txt",headEnd:"",tailStart:""},brainfuck:{mime:"text/plain",label:"Brainf**k",fold:"indent",suffix:"",langId:19,extension:"bf",defaultText:"",headEnd:"",tailStart:""},javascript:{mime:"text/javascript",label:"JavaScript (Node.js)",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:'function processData(input) {\n    //Enter your code here\n} \n\nprocess.stdin.resume();\nprocess.stdin.setEncoding("ascii");\n_input = "";\nprocess.stdin.on("data", function (input) {\n    _input += input;\n});\n\nprocess.stdin.on("end", function () {\n   processData(_input);\n});\n',suffix:"tern",langId:20,lsp:"javascript",extension:"js"},typescript:{mime:"text/typescript",label:"TypeScript",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"'use strict';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf-8');\nlet inputString: string = '';\nlet inputLines: string[] = [];\nlet currentLine: number = 0;\nprocess.stdin.on('data', function(inputStdin: string): void {\n    inputString += inputStdin;\n});\n\nprocess.stdin.on('end', function(): void {\n    inputLines = inputString.split('\\n');\n    inputString = '';\n    main();\n});\n\nfunction readLine(): string {\n    return inputLines[currentLine++];\n}\n\nfunction main() {\n    // Enter your code here\n}",suffix:"",langId:66,lsp:"typescript",extension:"ts"},d:{mime:"text/x-d",label:"D",fold:"brace",defaultText:"/* Enter your code here. Read input from STDIN. Print output to STDOUT */",suffix:"",langId:22,extension:"d",headEnd:"",tailStart:""},go:{mime:"text/x-go",label:"Go",fold:"brace",defaultText:'package main\nimport "fmt"\n\nfunc main() {\n //Enter your code here. Read input from STDIN. Print output to STDOUT\n}',suffix:"go",langId:21,lsp:"go",extension:"go",headEnd:"",tailStart:""},lua:{mime:"text/x-lua",label:"Lua",headEnd:"-- Head ends here",tailStart:"-- Tail starts here",fold:"indent",defaultText:"-- Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:18,extension:"lua"},erlang:{mime:"text/x-erlang",label:"Erlang",fold:"indent",defaultText:"% Enter your code here. Read input from STDIN. Print output to STDOUT\n% Your class should be named solution\n\n-module(solution).\n-export([main/0]).\n\nmain() ->\n\t.\n",suffix:"",langId:16,extension:"erl",headEnd:"",tailStart:""},sbcl:{mime:"text/x-common-lisp",label:"Common Lisp (SBCL)",headEnd:"; Head ends here",tailStart:"; Tail starts here",fold:"indent",defaultText:";; Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:26,extension:"sbcl"},ocaml:{mime:"text/x-ocaml",label:"OCaml",fold:"indent",defaultText:"(* Enter your code here. Read input from STDIN. Print output to STDOUT *)",suffix:"",langId:23,extension:"ml",headEnd:"",tailStart:""},pascal:{mime:"text/x-pascal",label:"Pascal",headEnd:"{ Head ends here }",tailStart:"{ Tail starts here }",fold:"indent",defaultText:"(* Enter your code here. Read input from STDIN. Print output to STDOUT *)",suffix:"",langId:25,extension:"pas"},python3:{mime:"text/x-python",label:"Python 3",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"python3",langId:30,lsp:"python3",extension:"py",syntax:"python"},groovy:{mime:"text/x-groovy",label:"Groovy",headEnd:"// Head ends here",tailStart:"// Tail starts here",fold:"brace",defaultText:"//Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:31,extension:"groovy"},text_pseudo:{mime:"text/plain",label:"Plain Text",fold:"indent",suffix:"",langId:7,extension:"txt",defaultText:"",headEnd:"",tailStart:""},objectivec:{mime:"text/x-csrc",label:"Objective-C",headEnd:"// Head ends here",tailStart:"// Tail starts here",fold:"brace",defaultText:"//Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"clang",langId:32,extension:"m",syntax:"objective-c"},fsharp:{mime:"text/x-fsharp",label:"F#",headEnd:"// Head ends here",tailStart:"// Tail starts here",fold:"indent",defaultText:"//Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:33,extension:"fs"},visualbasic:{mime:"text/x-vb",label:"VB.NET",headEnd:"' Head ends here",tailStart:"' Tail starts here",fold:"indent",defaultText:"'Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:37,extension:"vb",syntax:"vb"},cobol:{mime:"text/x-cobol",label:"COBOL",headEnd:"* Head ends here",tailStart:"* Tail starts here",fold:"indent",defaultText:"*Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:36,extension:"cobol"},tsql:{mime:"text/x-plsql",label:"MS SQL Server",suffix:"",langId:42,extension:"tsql",syntax:"sql",defaultText:"",headEnd:"",tailStart:""},lolcode:{label:"LOLCODE",headEnd:"BTW Head ends here",tailStart:"BTW Tail starts here",fold:"indent",defaultText:"BTW Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:38,extension:"lolcode"},smalltalk:{mime:"text/x-stsrc",label:"Smalltalk",headEnd:'" Head ends here"',tailStart:'" Tail starts here"',fold:"indent",defaultText:'"Enter your code here. Read input from STDIN. Print output to STDOUT"',suffix:"",langId:39,extension:"st",syntax:"st"},tcl:{mime:"text/x-tcl",label:"Tcl",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"brace",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:40,extension:"tcl"},html:{mime:"text/html",label:"HTML",headEnd:"\x3c!-- Head ends here --\x3e",tailStart:"\x3c!-- Tail starts here --\x3e",fold:"tag",defaultText:"\x3c!-- Enter your code here --\x3e",suffix:"",extension:"html"},css:{mime:"text/css",label:"CSS",headEnd:"/* Head ends here */",tailStart:"/* Tails starts here */",fold:"brace",defaultText:"/* Enter your code here*/",suffix:"",extension:"css"},java8:{mime:"text/x-java",label:"Java 8",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",suffix:"java",langId:43,lsp:"java",extension:"java",syntax:"java"},db2:{mime:"text/x-plsql",label:"DB2",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"indent",suffix:"",langId:44,extension:"db2",syntax:"sql",defaultText:""},octave:{mime:"text/x-octave",label:"Octave",headEnd:"# Head ends here",tailStart:"# Tail starts here ",fold:"indent",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:46,extension:"octave"},r:{mime:"text/x-rsrc",label:"R",headEnd:"# Head ends here",tailStart:"# Tail starts here ",fold:"brace",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:24,extension:"r"},xquery:{mime:"application/xquery",label:"XQuery",headEnd:"(: Head ends here :)",tailStart:"(: Tail starts here :)",fold:"indent",defaultText:"(: Enter your code here. Read input from STDIN. Print output to STDOUT :)",suffix:"",langId:48,extension:"xquery"},racket:{mime:"text/x-scheme",label:"Racket",headEnd:"; Head ends here",tailStart:"; Tail starts here",fold:"brace",defaultText:"#lang racket\n; Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:49,extension:"rkt"},xml:{mime:"text/xml",label:"XML",headEnd:"\x3c!-- Head ends here --\x3e",tailStart:"\x3c!-- Tail starts here --\x3e",fold:"tag",defaultText:"\x3c!-- Enter your code here --\x3e",suffix:"",extension:"xml"},rust:{mime:"text/x-rustsrc",label:"Rust",headEnd:"// Head ends here",tailStart:"// Tail starts here",fold:"brace",defaultText:"// Enter your code here ",suffix:"",langId:50,extension:"rs"},swift:{mime:"text/x-swift",label:"Swift",tailStart:"// Tail starts here",fold:"brace",defaultText:"import Foundation\n\n// Enter your code here ",suffix:"swift",langId:51,extension:"swift",lsp:"swift",headEnd:""},fortran:{mime:"text/x-fortran",label:"Fortran",headEnd:"! Head ends here",tailStart:"! Tail starts here",fold:"indent",defaultText:"! Enter your code here ",suffix:"",langId:54,extension:"fortran"},elixir:{mime:"text/elixir",label:"Elixir",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"defmodule Solution do\n#Enter your code here. Read input from STDIN. Print output to STDOUT\nend",suffix:"",langId:52,extension:"ex"},ada:{mime:"text/x-adasrc",label:"Ada",headEnd:"-- Head ends here",tailStart:"-- Tail starts here",fold:"indent",defaultText:"with Ada.Text_IO, Ada.Integer_Text_IO;\nuse Ada;\n\nprocedure Solution is\n-- Enter your code here. Read input from STDIN. Print output to STDOUT\n\n\nend Solution",suffix:"",langId:53,extension:"ada"},nim:{mime:"text/nim",label:"Nim",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here ",suffix:"",extension:"nim"},julia:{mime:"text/x-julia",label:"Julia",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here ",suffix:"",langId:57,extension:"julia"},pypy:{mime:"text/x-python",label:"Pypy 2",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:61,extension:"py",syntax:"python"},pypy3:{mime:"text/x-python",label:"Pypy 3",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:62,extension:"py",syntax:"python"},cpp14:{mime:"text/x-c++src",label:"C++14",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    return 0;\n}\n",suffix:"clang",langId:58,lsp:"cpp",extension:"cpp",syntax:"cpp"},coffeescript:{mime:"text/x-coffeescript",label:"CoffeeScript",headEnd:"# Head ends here",tailStart:"# Tail starts here",fold:"indent",defaultText:"# Enter your code here",suffix:"",langId:59,extension:"coffeescript"},kotlin:{mime:"text/x-kotlin",label:"Kotlin",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"import java.io.*\nimport java.util.*\n\nfun main(args: Array<String>) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. */\n}",suffix:"",lsp:"kotlin",langId:71,extension:"kt"},dart:{mime:"text/x-dart",label:"Dart",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"// Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",langId:27,extension:"dart"},whitespace:{label:"Whitespace",headEnd:"Head ends here",tailStart:"Tail starts here",fold:"indent",defaultText:"Enter your code here. Read input from STDIN. Print output to STDOUT",suffix:"",extension:"ws"},java15:{mime:"text/x-java",label:"Java 15",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",suffix:"java",langId:75,lsp:"java15",extension:"java",syntax:"java"},cpp20:{mime:"text/x-c++src",label:"C++20",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"brace",defaultText:"#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    return 0;\n}\n",suffix:"clang",langId:76,lsp:"cpp",extension:"cpp",syntax:"cpp"},verilog:{mime:"text/x-verilog",label:"Verilog",headEnd:"/* Head ends here */",tailStart:"/* Tail starts here */",fold:"indent",defaultText:"module main;\n  initial\n    begin\n      /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n      \n      $finish;\n    end\nendmodule",suffix:"",langId:77,extension:"v"}},o=Object.keys(i).filter(e=>void 0!==i[e].lsp);n.default=i},Bftv:function(e,n,t){"use strict";var i=t("pVnL"),o=t.n(i),r=t("MVZn"),a=t.n(r),s=t("QILm"),l=t.n(s),d=t("cDcd"),c=t.n(d);t("Jkfs");n.a=e=>{let n=e.className,t=void 0===n?"":n,i=l()(e,["className"]);return i=a()({},i,{className:t+" ui-svg-icon"}),c.a.createElement("svg",o()({viewBox:"0 0 24 24",width:"1em",height:"1em"},i,{fill:"currentColor"}),c.a.createElement("path",{d:"M12 1C5.9 1 1 5.9 1 12s4.9 11 11 11 11-4.9 11-11S18.1 1 12 1zm0 20c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9z"}),c.a.createElement("path",{d:"M15.7 8.3c-.4-.4-1-.4-1.4 0L12 10.6 9.7 8.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l2.3 2.3-2.3 2.3c-.4.4-.4 1 0 1.4.2.2.4.3.7.3s.5-.1.7-.3l2.3-2.3 2.3 2.3c.2.2.5.3.7.3s.5-.1.7-.3c.4-.4.4-1 0-1.4L13.4 12l2.3-2.3c.4-.4.4-1 0-1.4z"}))}},CEzC:function(e,n,t){"use strict";t.r(n),t.d(n,"defaultCodeshellOpts",(function(){return s})),t.d(n,"getCodeshellUserOpts",(function(){return l})),t.d(n,"getCodeBody",(function(){return d})),t.d(n,"fetchUserPreference",(function(){return c})),t.d(n,"setUserPreference",(function(){return p})),t.d(n,"getLocalStorageValue",(function(){return u})),t.d(n,"setLocalStorageValue",(function(){return f}));var i=t("vmXh"),o=t.n(i),r=t("MrcO");const a="function"==typeof $&&$.jStorage||r.a,s={theme:"light",tabSize:4,intellisense:!0,mode:"normal",keyMap:"sublime",indentUnit:4};function l(){let e=a.get("codeshellUserOpts"),n=!1;if(e)try{e=JSON.parse(e)}catch(t){e=s,n=!0}else e=s,n=!0;return n&&a.set("codeshellUserOpts",JSON.stringify(s)),e}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",n=arguments.length>1?arguments[1]:void 0,t=arguments.length>2?arguments[2]:void 0,i=e;if(n.trim()&&0===i.indexOf(n)&&(i=i.substr(n.length)),t.trim()){const e=i.lastIndexOf(t);e>0&&(i=i.substr(0,e))}return i.endsWith("\n")||(i+="\n"),i}function c(e){return l()[e]}function p(e,n){const t=l(),i={vim:"vim",emacs:"emacs",normal:"sublime"};var r,s;t[e]=n,"tabSize"===e?t.indentUnit=n:"mode"===e?t.keyMap=i[n]:"intellisense"===e?(s=n,o.a.set("enableIntellisenseUserPref",s)):"theme"===e&&(r=n,o.a.set("hacker_editor_theme",{light:"light",dark:"dark",contrast:"dark"}[r]||r)),a.set("codeshellUserOpts",JSON.stringify(t))}function u(e){return a.get(e)}function f(e,n){a.set(e,n)}},Gu5L:function(e,n,t){"use strict";var i=t("pVnL"),o=t.n(i),r=t("QILm"),a=t.n(r),s=t("cDcd"),l=t.n(s),d=t("TSYQ"),c=t.n(d),p=t("KD+3"),u=t("hwBa"),f=t("2grx"),h=t("rorp"),m=t("lSNA"),g=t.n(m);const b=["value"],v={DropdownIndicator:null},y=e=>({label:e,value:e});class S extends s.Component{constructor(){var e;super(...arguments),e=this,g()(this,"state",{inputValue:""}),g()(this,"handleInputChange",e=>{this.setState({inputValue:e})}),g()(this,"handleKeyDown",e=>{const n=this.state.inputValue,t=this.props,i=t.onChange,o=t.value,r=o||[];if(n)switch(e.key){case"Enter":case"Tab":i([...r,y(n)]),this.setState({inputValue:""}),e.preventDefault()}}),g()(this,"handleBlur",(function(){const n=e.state.inputValue,t=e.props,i=t.onBlur,o=t.onChange,r=t.value,a=r||[];i&&i(...arguments),n&&(o([...a,y(n)]),e.setState({inputValue:""}))}))}render(){const e=this.state.inputValue,n=this.props,t=n.value,i=a()(n,b);return l.a.createElement(f.a,o()({},i,{isMulti:!0,components:v,inputValue:e,menuIsOpen:!1,onInputChange:this.handleInputChange,onKeyDown:this.handleKeyDown,onBlur:this.handleBlur,value:t}))}}var L=S,E=t("53eb");t("7Iy7");t.d(n,"e",(function(){return I})),t.d(n,"a",(function(){return T})),t.d(n,"c",(function(){return w})),t.d(n,"b",(function(){return P})),t.d(n,"d",(function(){return A}));const k=["error","variant","className"];function x(e){return function(n){const t=n.error,i=n.variant,r=void 0===i?"inset":i,s=n.className,d=a()(n,k);return l.a.createElement("div",{className:c()("custom-select",s)},l.a.createElement(e,o()({styles:Object(E.a)(t,r)},d)))}}const I=x(p.a),T=x(u.a),w=x(f.a),P=x(h.a),A=x(L)},MrcO:function(e,n,t){"use strict";t("rGqo");var i=t("lSNA"),o=t.n(i),r=t("eOGF");function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}const s="undefined"==typeof localStorage?new class extends Object{setItem(e,n){this[e]=n}getItem(e){return this[e]}removeItem(e){delete this[e]}}:localStorage,l=new class{constructor(e,n){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};o()(this,"dbName",void 0),o()(this,"namespace",void 0),o()(this,"intermediateStore",{}),o()(this,"persistentStore",void 0),o()(this,"onWindowUnload",void 0),o()(this,"flushIntervalID",void 0);const i=t.namespace,r=void 0===i?"":i,a=t.persistOnUnload,s=void 0===a||a,l=t.flushInterval,d=void 0===l?3e3:l;this.dbName=n,this.namespace=r,this.persistentStore=e,!r&&n&&this.initBaseStore(s,n),this.flushIntervalID=setInterval(()=>this.flush(),d)}initBaseStore(e,n){try{const e=this.persistentStore.getItem(n);if(e){const n=JSON.parse(e);this.intermediateStore=n}}catch(e){this.intermediateStore={}}e&&!Object(r.F)()&&window.addEventListener("beforeunload",()=>this.flush())}flush(){try{this.persistentStore.setItem(this.dbName,JSON.stringify(this.intermediateStore))}catch(e){console.error(e)}}getKey(e){return this.namespace?`${this.namespace}-${e}`:e}setItem(e,n){this.intermediateStore[this.getKey(e)]=n}getItem(e){return this.intermediateStore[this.getKey(e)]}set(e,n){return this.setItem(e,n)}get(e){return this.getItem(e)}removeItem(e){delete this.intermediateStore[this.getKey(e)]}deleteKey(e){return this.removeItem(e)}storageObj(){return function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}({},this.intermediateStore)}index(){return Object.keys(this.intermediateStore)}removePrefix(e){Object.keys(this.intermediateStore).forEach(n=>{n.startsWith(e)&&delete this.intermediateStore[n]})}createNamespace(e){if(!e)throw new Error("Cannot create storage without namespace");const n=Object.create(this);return n.namespace=this.getKey(e),n}remove(){this.namespace&&this.removePrefix(this.namespace)}}(s,"jStorage");"undefined"!=typeof window&&(window.jStorage=l,window.$=window.$||{},window.$.jStorage=l);n.a=l},PQTS:function(e,n,t){"use strict";var i=t("pVnL"),o=t.n(i),r=t("MVZn"),a=t.n(r),s=t("QILm"),l=t.n(s),d=t("cDcd"),c=t.n(d);t("Jkfs");n.a=e=>{let n=e.className,t=void 0===n?"":n,i=l()(e,["className"]);return i=a()({},i,{className:t+" ui-svg-icon"}),c.a.createElement("svg",o()({viewBox:"0 0 24 24",width:"1em",height:"1em"},i,{fill:"currentColor"}),c.a.createElement("path",{d:"M23 17.5L14.6 3.3c-.4-.7-1.1-1.2-1.9-1.4-.8-.2-1.6-.1-2.3.3-.4.2-.8.6-1 1L1 17.5c-.8 1.4-.3 3.3 1.1 4.1.4.3.9.4 1.4.4h17c.8 0 1.6-.3 2.1-.9.6-.6.9-1.3.9-2.1-.1-.5-.2-1.1-.5-1.5zm-1.8 2.2c-.2.2-.5.3-.7.3h-17c-.2 0-.3 0-.5-.1-.5-.3-.6-.9-.4-1.4l8.5-14.1c.1-.1.2-.3.3-.3.5-.3 1.1-.1 1.4.3l8.5 14.1c.1.1.1.3.1.5.1.3-.1.5-.2.7z"}),c.a.createElement("path",{d:"M12 8c-.6 0-1 .4-1 1v4c0 .6.4 1 1 1s1-.4 1-1V9c0-.6-.4-1-1-1zm.7 8.3c-.4-.4-1.1-.4-1.4 0-.1.1-.2.2-.2.3 0 .1-.1.2-.1.4 0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3c.1-.1.2-.2.2-.3 0-.1.1-.2.1-.4s0-.3-.1-.4c0-.1-.1-.2-.2-.3z"}))}},Wgjw:function(e,n,t){"use strict";t.d(n,"g",(function(){return i})),t.d(n,"c",(function(){return o})),t.d(n,"d",(function(){return r})),t.d(n,"h",(function(){return a})),t.d(n,"a",(function(){return s})),t.d(n,"f",(function(){return l})),t.d(n,"e",(function(){return d})),t.d(n,"b",(function(){return c}));const i=Object.freeze({CONNECT:"connect",RECONNECT:"reconnect",CLOSE:"close",ERROR:"error"}),o=Object.freeze({CONNECT:"lspConnect",READY:"lspReady",CLOSE:"lspClose",DISCONNECT:"lspDisconnect",ERROR:"lspError"}),r=Object.freeze({LOADING:"loading",READY:"ready",ERROR:"error",DISABLED:"disabled",NOT_SUPPORTED:"none"}),a={["autocomplete."+r.LOADING]:"Autocomplete Loading",["autocomplete."+r.READY]:"Autocomplete Ready",["autocomplete."+r.ERROR]:"Autocomplete Errored",["autocomplete."+r.DISABLED]:"Autocomplete Disabled",["autocomplete."+r.NOT_SUPPORTED]:"Autocomplete Not Supported",[`autocomplete.${r.NOT_SUPPORTED}_tooltip`]:"We do not support Autocomplete for this language yet"},s=Object.freeze(["textDocument/codeAction","textDocument/codeLens","textDocument/formatting","textDocument/foldingRange","textDocument/rangeFormatting","textDocument/onTypeFormatting","workspace/executeCommand"]),l=Object.freeze({EDITOR_MODE:"mode",THEME:"theme",TAB_SIZE:"tabSize",AUTOCOMPLETE:"intellisense"}),d=Object.freeze([{id:l.EDITOR_MODE,label:"Editor Mode",items:[{label:"Emacs",value:"emacs"},{label:"Normal",value:"normal"},{label:"Vim",value:"vim"}]},{id:l.THEME,label:"Theme",items:[{label:"Light",value:"light"},{label:"Dark",value:"dark"},{label:"High Contrast",value:"contrast"}]},{id:l.TAB_SIZE,label:"Tab Spaces",items:[{label:"2 spaces",value:2},{label:"4 spaces",value:4},{label:"8 spaces",value:8}]},{id:l.AUTOCOMPLETE,label:"Autocomplete",items:[{label:"Enable",value:!0},{label:"Disable",value:!1}]}]),c=Object.freeze({SPACE:32,ENTER:13,UP:38,DOWN:40,LEFT:37,RIGHT:39,ESC:27,TAB:9})},YqDo:function(e,n,t){"use strict";var i=t("pVnL"),o=t.n(i),r=t("MVZn"),a=t.n(r),s=t("QILm"),l=t.n(s),d=t("cDcd"),c=t.n(d);t("Jkfs");n.a=e=>{let n=e.className,t=void 0===n?"":n,i=l()(e,["className"]);return i=a()({},i,{className:t+" ui-svg-icon"}),c.a.createElement("svg",o()({viewBox:"0 0 36 36",width:"1em",height:"1em"},i,{fill:"currentColor"}),c.a.createElement("path",{d:"M18 0c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm0 14c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm0 14c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z",fillRule:"evenodd",clipRule:"evenodd"}))}},cojC:function(e,n,t){},cqES:function(e,n,t){"use strict";var i=t("pVnL"),o=t.n(i),r=t("MVZn"),a=t.n(r),s=t("QILm"),l=t.n(s),d=t("cDcd"),c=t.n(d);t("Jkfs");n.a=e=>{let n=e.className,t=void 0===n?"":n,i=l()(e,["className"]);return i=a()({},i,{className:t+" ui-svg-icon"}),c.a.createElement("svg",o()({viewBox:"0 0 100 100",width:"1em",height:"1em"},i,{fill:"currentColor"}),c.a.createElement("path",{d:"M25.885 65.414a19.77 19.77 0 0 0-5.791 13.98v7.675H14.15V95h71.7v-7.931h-5.944v-7.675a19.77 19.77 0 0 0-5.79-13.98L60.741 52.041a2.887 2.887 0 0 1 0-4.082l13.373-13.373a19.77 19.77 0 0 0 5.791-13.98v-7.675h5.944V5h-71.7v7.931h5.944v7.675a19.77 19.77 0 0 0 5.79 13.98L39.259 47.96a2.887 2.887 0 0 1 0 4.082L25.885 65.414zM44.18 43.037L30.807 29.664a12.725 12.725 0 0 1-3.752-9.058v-8.645h45.89v8.645c0 3.422-1.332 6.639-3.752 9.058L55.82 43.037A9.783 9.783 0 0 0 52.936 50a9.783 9.783 0 0 0 2.885 6.963l13.372 13.374c1.572 1.571 2.63 3.5 3.216 5.582C69.474 73.637 54.443 62.124 50 62.124c-4.444 0-19.474 11.513-22.41 13.795.588-2.083 1.645-4.01 3.217-5.583L44.18 56.963c3.839-3.839 3.84-10.086 0-13.926z"}))}},fKZA:function(e,n,t){},gNz3:function(e,n,t){},iiin:function(e,n,t){"use strict";var i=t("pVnL"),o=t.n(i),r=t("QILm"),a=t.n(r),s=t("cDcd"),l=t.n(s),d=t("TSYQ"),c=t.n(d),p=t("37OS"),u=t.n(p);t("gNz3");const f=["iconProps","size","btnText","tooltip","Icon","disabled","className"];function h(e){const n=e.iconProps,t=e.size,i=e.btnText,r=e.tooltip,s=e.Icon,d=e.disabled,p=e.className,h=a()(e,f),m=r&&!d?{"data-balloon":i,"data-balloon-pos":"up"}:{},g=d?u.a:e.onClick;return l.a.createElement("button",o()({className:c()("ui-icon-btn","ui-btn-"+t,p),disabled:d},m,h,{onClick:g}),!r&&l.a.createElement("span",{className:"sr-only"},i),l.a.createElement(s,o()({"aria-hidden":!0,focusable:"false"},n)))}h.defaultProps={iconProps:{},size:"normal",tooltip:!0,disabled:!1},n.a=h},onCv:function(e,n,t){},vY1X:function(e,n,t){"use strict";t.r(n);var i=t("OyKl"),o=t("kGKp"),r=(t("KKXr"),t("pIFo"),t("rGqo"),t("lSNA")),a=t.n(r),s=t("cDcd"),l=t.n(s),d=t("wsa1"),c=t("vN+2"),p=t.n(c),u=t("2iqK");function f(e,n,t,i){const o=[];if(i.head){const e=n.endsWith("\n")?n:n+"\n";o.push({range:new d.Range(1,1,1,1),text:e})}if(i.tail){const i=n.startsWith("\n")?t:"\n"+t,r=e.getModel().getLineCount()+1;o.push({range:new d.Range(r,1,r,1),text:i})}0!==o.length&&e.executeEdits("krackjack",o)}var h={base:"vs",inherit:!0,rules:[{token:"storage",foreground:"0000ff",fontStyle:"bold"},{token:"punctuation",foreground:"137C36"},{token:"comment",foreground:"137C36"},{token:"number",foreground:"137C36"},{token:"attribute.value.number",foreground:"137C36"},{token:"attribute.value.unit",foreground:"137C36"},{token:"type.identifier",foreground:"025F59"},{token:"attribute.name",foreground:"d11534"},{token:"metatag.content.html",foreground:"d11534"},{token:"metatag.html",foreground:"576871"}],colors:{"editor.lineHighlightBorder":"#57687170"}};var m={base:"vs-dark",inherit:!0,rules:[{token:"punctuation",foreground:"ffffff"},{token:"storage",foreground:"569cd6",fontStyle:"bold"},{token:"keyword",foreground:"ff636f",fontStyle:"bold"},{token:"string",foreground:"9ddf6e"},{token:"identifier",foreground:"63b7fc"},{token:"comment",foreground:"8c96a6",fontStyle:"italic"}],colors:{"editor.background":"#1d2432","editorLineNumber.foreground":"#8c96a6"}};t("onCv");function g(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function b(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?g(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):g(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}d.editor.defineTheme("light",h),d.editor.defineTheme("dark",m),d.editor.defineTheme("contrast",{base:"hc-black",inherit:!0,rules:[{token:"punctuation",foreground:"608b4e"},{token:"storage",foreground:"569cd6",fontStyle:"bold"}],colors:{"editor.lineHighlightBackground":"#282a2e"}}),d.languages.register({id:"verilog"}),d.languages.onLanguage("python",()=>{t.e(132).then(t.bind(null,"GfaK")).then(e=>{let n=e.configuration;d.languages.setLanguageConfiguration("python",n)}).catch(e=>{console.log("Unable to load python configuration",e)})}),d.languages.onLanguage("verilog",()=>{t.e(133).then(t.bind(null,"l8i+")).then(e=>{let n=e.configuration,t=e.language;d.languages.setMonarchTokensProvider("verilog",t),d.languages.setLanguageConfiguration("verilog",n)}).catch(e=>{console.log("Unable to load verilog configuration",e)})});class v extends l.a.Component{constructor(e){super(e),a()(this,"editorState",void 0),a()(this,"editor",void 0),a()(this,"editorElement",void 0),a()(this,"oldDecorations",void 0),a()(this,"disposables",void 0),a()(this,"foldingDisposable",void 0),a()(this,"headRange",void 0),a()(this,"tailRange",void 0),a()(this,"foldTimer",void 0),a()(this,"undoStackClearTimer",void 0),a()(this,"editorRef",e=>{this.editorElement=e}),this.editorState={currentValue:this.generateCurrentCode(),options:this.getEditorOptions(),model:this.createModel("")},this.oldDecorations=[],this.disposables=[],this.foldingDisposable=null,this.headRange=null,this.tailRange=null,this.foldTimer=null}componentDidMount(){const e=this.props.stackClearInterval,n=this.editorState.options,t=d.editor.create(this.editorElement,b({},n,{model:null}));this.editor=t,this.initializeEditor(),e&&(this.undoStackClearTimer=setInterval(()=>this.clearUndoStack(),e))}componentDidUpdate(e){const n={},t=this.props,i=t.language,o=t.options,r=t.cleanUpLsp,a=t.code,s=t.tabSize,l=t.insertSpaces,d=t.retainValueOnLanguageChange,c=this.editorState.model;let p=!0;if(this.editor&&this.updateEditorUI(e),e.language!==i){p=!1,r();const e=c.getValue();n.currentValue=d?e:this.generateCurrentCode(),n.model=this.createModel(d?e:"")}else{let n=null;e.tabSize!==s&&(n=n||{},n.tabSize=s),e.insertSpaces!==l&&(n=n||{},n.insertSpaces=l),n&&this.editorState.model.updateOptions(n)}e.options!==o&&(n.options=this.getEditorOptions()),e.code!==a&&(n.currentValue=this.generateCurrentCode(),e.language===i&&this.addFoldingProvider(!0)),Object.keys(n).length&&this.setEditorState(n,p)}componentWillUnmount(){this.foldingDisposable&&this.foldingDisposable.dispose(),this.disposables.forEach(e=>e.dispose()),this.editorState.model.dispose(),this.editor.dispose(),this.foldTimer&&clearTimeout(this.foldTimer),this.undoStackClearTimer&&clearInterval(this.undoStackClearTimer)}clearUndoStack(){const e=this.editorState.model;e._commandManager.past.length>100&&(e._commandManager.past=e._commandManager.past.slice(-100))}initializeEditor(){const e=this.editor,n=this.editorState,t=n.model,i=n.currentValue,o=this.props,r=o.editorDidMount,a=o.autoFocus;this.disposables.push(e.onDidChangeModelContent(this.onContentChange.bind(this))),this.disposables.push(e.onDidPaste(this.onPaste.bind(this))),this.updateCoreData(t,i),this.updateEditorUI(null),a&&this.focus(!0),this.addCustomActions(),r(e)}updateEditorUI(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;e||(e={});const n=this.props,t=n.theme,i=n.width,o=n.height;t!==e.theme&&d.editor.setTheme(t),i===e.width&&o===e.height||this.editor.layout()}onContentChange(e){const n=this.props,t=n.onHeadTailType,i=n.onReadonlyType,o=n.code,r=o.headEnd,a=o.tailStart,s=n.onChange,l=n.isReadonlyEditable,d=n.originalHead,c=n.originalTail,p=this.editorState.currentValue,f=this.editor.getValue();let h=f,m=!0;if(l){const e=Object(u.h)(f,d,c);(e.head||e.tail)&&t(e),this.setReadOnlyRangeData()}else f.trim()||!r&&!a?Object(u.l)(f,r,a)||(h=p,m=!1):h=`${r}\n\n\n${a}`,this.setEditorState({currentValue:h});m?s&&s(e,h,r,a):i()}onPaste(e){const n=this.editorState.model,t=this.props,i=t.tabSize,o=t.onPaste,r=t.insertSpaces,a=t.isReadonlyEditable;let s=n.getValueInRange(e);if(r&&s.includes("\t")){let n="";const t="number"==typeof i?i:4;for(let e=0;e<t;e++)n+=" ";s=s.replace(/\t/g,n),this.editor.executeEdits("krackjack",[{range:e,text:s}])}o&&o(e,s),a||this.adjustCursor()}adjustCursor(){setTimeout(()=>{const e=this.editor.getPosition();this.headRange&&this.headRange.containsPosition(e)?this.editor.setPosition(new d.Position(this.headRange.endLineNumber+1,1)):this.tailRange&&this.tailRange.containsPosition(e)&&this.editor.setPosition(new d.Position(this.tailRange.startLineNumber-1,1))},0)}addCustomActions(){["cquery.showReferences","java.show.references"].forEach(e=>{this.editor._commandService.addCommand({id:e,handler:(e,n,t)=>{this.editor.setPosition(new d.Position(t.line+1,t.character+1))}})})}updateHeadRange(e,n){const t=this.props,i=t.originalHead,o=t.isReadonlyEditable;let r=[];if(n?r=n.split("\n"):i&&o&&(r=i.split("\n")),r.length){const e=1,n=1,t=r.length,i=r[r.length-1].length+1;this.headRange=new d.Range(e,n,t,i)}else this.headRange=null}updateTailRange(e,n){const t=this.props,i=t.originalTail,o=t.isReadonlyEditable;if(!n&&!i)return void(this.tailRange=null);let r=[];n?r=n.split("\n"):i&&o&&(r=i.split("\n"));const a=e.getLineCount();r.length&&(this.tailRange=new d.Range(a-r.length+1,1,a,r[r.length-1].length+1))}setReadOnlyRangeData(e){const n=this.props,t=n.code,i=t.headEnd,o=t.tailStart,r=n.originalHead,a=n.originalTail;(i||o||r||a)&&(e||(e=this.editorState.model),this.updateHeadRange(e,i),this.updateTailRange(e,o),this.updateReadOnlyUI())}updateReadOnlyUI(){const e=[];this.headRange&&e.push(this.headRange),this.tailRange&&e.push(this.tailRange),this.oldDecorations=this.editor.deltaDecorations(this.oldDecorations||[],e.map(e=>({range:e,options:{isWholeLine:!0,className:"read-only",stickiness:d.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges}})))}updateCoreData(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const i=this.props.onCodeFold;this.editor.setModel(e),t&&this.editor.updateOptions(t),n?this.setValueAndRange(e,n):i()}setValueAndRange(e,n){n&&(!function(e,n){e.applyEdits([{range:e.getFullModelRange(),text:n,forceMoveMarkers:!0}])}(e,n),this.setReadOnlyRangeData(e),this.addFoldingProvider())}addFoldingProvider(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.foldingDisposable&&this.foldingDisposable.dispose();const n=this.props,t=n.syntax,i=n.language,o=n.code,r=o.headEnd,a=o.tailStart,s=n.enableHeadTailFolding,l=n.onCodeFold,c=n.originalHead,p=n.originalTail;if(!s||!r&&!a&&!c&&!p)return void l();let u=0,f=0;r?u=r.split("\n").length:c&&(u=c.split("\n").length),a?f=a.split("\n").length:p&&(f=p.split("\n").length),this.foldingDisposable=d.languages.registerFoldingRangeProvider(t||i,{provideFoldingRanges:e=>{const n=[];if(u&&n.push({start:1,end:u,kind:d.languages.FoldingRangeKind.Imports}),f){const t=e.getLineCount();n.push({start:t-f+1,end:t,kind:d.languages.FoldingRangeKind.Region})}return n}}),this.foldTimer=setTimeout(()=>{this.editor.getAction("editor.foldAll").run(),l()},e?0:500)}focus(){if(!(arguments.length>0&&void 0!==arguments[0]&&arguments[0])||!this.headRange&&!this.tailRange)return void this.editor.focus();let e=new d.Position(1,1);this.headRange&&(e=new d.Position(this.headRange.endLineNumber+1,1)),this.editor.setPosition(e),this.editor.focus()}setUndoableValue(e){const n=this.editorState.model,t=n.getLineCount();this.editor.executeEdits("krackjack",[{range:new d.Range(1,1,t+1,1),text:e}]),n._commandManager.past.pop(),this.setReadOnlyRangeData(null),this.resetCursorAndFold()}resetCursorAndFold(){this.focus(!0);const e=this.editor.getAction("editor.foldAll");"function"==typeof e&&e.run()}stripHeadTail(e){const n=this.props.code,t=n.headEnd,i=n.tailStart;let o=e;if(t&&0===e.indexOf(t)&&(o=o.substr(t.length)),i){const e=o.lastIndexOf(i);e>0&&(o=o.substr(0,e))}return o}setEditorState(e){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const t=this.editorState;this.editorState=b({},t,{},e),this.rerenderEditor(t,n)}rerenderEditor(e){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const t=this.editorState;if(t.options!==e.options&&this.editor.updateOptions(t.options),t.model!==e.model)return this.updateCoreData(t.model,t.currentValue),e.model.dispose(),void(n&&this.focus(!0));t.currentValue!==this.editor.getValue()?this.setUndoableValue(t.currentValue):t.currentValue!==e.currentValue&&this.setReadOnlyRangeData(null)}generateCurrentCode(){const e=this.props.code,n=e.headEnd,t=e.tailStart,i=e.defaultText;return Object(u.c)(n,i,t)}getEditorOptions(){return b({minimap:{enabled:!1},autoIndent:!0,formatOnPaste:!1,fontFamily:"SourceCodePro, monospace",formatOnType:!1,automaticLayout:!0,scrollBeyondLastLine:!1,showFoldingControls:"always",wordBasedSuggestions:!1},this.props.options)}createModel(e){const n=this.props,t=n.modelUri,i=n.fileName,o=n.fileExtension,r=n.syntax,a=n.language,s=n.insertSpaces,l=n.tabSize,c=d.Uri.parse(`${t}/${i}.${o}`);let p=d.editor.getModel(c);return p||(p=d.editor.createModel(e,r||a,c),p.setEOL(d.editor.EndOfLineSequence.LF),p.updateOptions({tabSize:l,insertSpaces:s,trimAutoWhitespace:!1}),p)}render(){const e=this.props.height;return l.a.createElement("div",{ref:this.editorRef,className:"hr-monaco-base-editor",style:{height:e}})}}a()(v,"defaultProps",{code:{headEnd:"",tailStart:"",defaultText:""},modelUri:"file://workspace",fileName:"file",options:{},height:400,theme:"vs",autoFocus:!0,insertSpaces:!0,enableHeadTailFolding:!1,tabSize:4,cleanUpLsp:p.a,editorDidMount:p.a,onCodeFold:p.a,onChange:p.a,onPaste:p.a,onReadonlyType:p.a,onHeadTailType:p.a,isReadonlyEditable:!1,stackClearInterval:6e4,retainValueOnLanguageChange:!1});var y=t("pVnL"),S=t.n(y),L=t("QILm"),E=t.n(L),k=t("yXPU"),x=t.n(k),I=t("Wgjw");function T(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function w(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?T(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):T(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var P=e=>{var n,i;return i=n=class extends l.a.Component{constructor(){var e,n;super(...arguments),e=this,n=this,a()(this,"editor",void 0),a()(this,"disposables",[]),a()(this,"thenables",Promise.resolve()),a()(this,"lspClient",void 0),a()(this,"editorDidMount",e=>{const n=this.props.editorDidMount;n&&n(e),this.editor=e,this.disposables.push(e.onDidChangeModel(this.startLspClient)),this.startLspClient()}),a()(this,"onWSConnect",(e,n)=>{const t=this.props.onLspWebsocketChange;let i;i=0===e?{event:I.g.CONNECT,eventData:{},language:n}:{event:I.g.RECONNECT,eventData:{retryCount:e},language:n},t(i)}),a()(this,"onWSClose",e=>{(0,this.props.onLspWebsocketChange)({event:I.g.CLOSE,eventData:{},language:e})}),a()(this,"onWSError",e=>{(0,this.props.onLspWebsocketChange)({event:I.g.ERROR,eventData:{},language:e})}),a()(this,"onWSLog",(e,n)=>{const t=this.props.onLspLog;t&&t(e,n)}),a()(this,"onLspConnect",e=>{(0,this.props.onLspWebsocketChange)({event:I.c.CONNECT,eventData:{},language:e})}),a()(this,"onLspReady",e=>{const n=this.props,t=n.onLspWebsocketChange,i=n.language;["python","python3"].includes(i)&&this.lspClient.languageClient.sendNotification("workspace/didChangeConfiguration",{settings:{python:{linting:{enabled:!0}}}});t({event:I.c.READY,eventData:{},language:e})}),a()(this,"onLspClose",e=>{(0,this.props.onLspWebsocketChange)({event:I.c.CLOSE,eventData:{},language:e})}),a()(this,"onLspError",(function(n,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const o=e.props.onLspWebsocketChange,r={event:I.c.ERROR,eventData:{message:n,fromServer:i},language:t};o(r)})),a()(this,"onLspDisconnect",e=>{(0,this.props.onLspWebsocketChange)({event:I.c.DISCONNECT,eventData:{},language:e})}),a()(this,"createLSPClient",()=>{const e=this.props.language;if("javascript"!==e&&"typescript"!==e)return this.loadLspClient().then(e=>{let n=e.default;const t=this.getLSPClientConfig();this.lspClient=new n(this.editor,t)});this.onLspReady(e)}),a()(this,"startLspClient",()=>{const e=this.props,n=e.enableAutoComplete,t=e.lspEndpoint,i=e.lspBaseUrl;n&&i&&t&&(this.thenables=this.thenables.then(this.stopLspClient).then(this.createLSPClient))}),a()(this,"stopLspClient",x()((function*(){n.lspClient&&(yield n.lspClient.dispose(),n.lspClient=null),n.prevListener&&(n.prevListener.dispose(),n.prevListener=null)}))),a()(this,"proxyLspInitialize",(n,t)=>function(i,o){try{for(var r=arguments.length,a=new Array(r>2?r-2:0),s=2;s<r;s++)a[s-2]=arguments[s];return t.apply(n,[i,o,...a]).then(e.onLspReady)}catch(e){return Promise.reject()}}),a()(this,"proxyLspSendRequest",(n,t)=>{let i;const o=this.props.onCompletionReceive;return function(r,a){let s;try{for(var l=arguments.length,d=new Array(l>2?l-2:0),c=2;c<l;c++)d[c-2]=arguments[c];s=t.apply(n,[r,a,...d])}catch(e){return s=Promise.reject(),s}if("object"==typeof r&&r.method){if("textDocument/completion"!==r.method&&"completionItem/resolve"!==r.method)return s;if("completionItem/resolve"===r.method)return s.then(e=>w({},e,{additionalTextEdits:void 0}));if("textDocument/completion"===r.method){const n=Date.now();return i&&(i.dispose(),i=null),s.then(e=>{const t=e.items||e,i={timeTaken:Date.now()-n,totalItems:t.length,startTime:n};o&&o(i)}).catch(()=>{i&&(i.dispose(),i=null,e.prevListener=i)}),e.prevListener=i,s.then(e=>(e.items||e).map(e=>w({},e,{additionalTextEdits:void 0})))}}}})}componentDidUpdate(e){if(!this.editor)return;const n=this.props,t=n.enableAutoComplete,i=n.language,o=e.language,r=e.enableAutoComplete;t||(this.thenables=this.thenables.then(this.stopLspClient)),t&&!r&&i===o&&(this.thenables=this.thenables.then(this.createLSPClient))}componentWillUnmount(){this.thenables.then(this.stopLspClient),this.disposables.forEach(e=>e.dispose())}loadLspClient(){return t.e(261).then(t.bind(null,"rDh+"))}getLSPClientConfig(){const e=this.props,n=e.userId,t=e.lspEndpoint,i=e.lspBaseUrl,o=e.modelUri,r=e.language,a=e.syntax,s=e.onCompletionReceive;return{userId:n,lspBaseUrl:i,lspEndpoint:t,modelUri:o,language:a||r,proxyInitialize:this.proxyLspInitialize,proxySendRequest:s?this.proxyLspSendRequest:null,onLspError:this.onLspError,onLspClose:this.onLspClose,onLspConnect:this.onLspConnect,onLspDisconnect:this.onLspDisconnect,onConnect:this.onWSConnect,onClose:this.onWSClose,onError:this.onWSError,onLspLog:this.onWSLog}}render(){const n=this.props,t=(n.enableAutoComplete,n.lspBaseUrl,n.lspEndpoint,n.onCompletionReceive,n.onLspWebsocketChange,E()(n,["enableAutoComplete","lspBaseUrl","lspEndpoint","onCompletionReceive","onLspWebsocketChange"]));return l.a.createElement(e,S()({},t,{editorDidMount:this.editorDidMount,cleanUpLsp:this.stopLspClient}))}},a()(n,"displayName",`withLsp(${Object(u.e)(e)})`),a()(n,"defaultProps",{editorDidMount:p.a,enableAutoComplete:!1,lspBaseUrl:"lsp.hackerrank.engineering",lspEndpoint:"",onCompletionReceive:null,modelUri:"file:///workspace",syntax:"",onLspWebsocketChange:p.a}),i},A=t("cqES"),C=t("IU/7"),O=t("Bftv"),R=t("PQTS"),_=t("PtY2"),N=t("61np");t("2sXX");const D=Object.freeze({[I.d.LOADING]:{Icon:A.a,className:"loading"},[I.d.READY]:{Icon:C.a,className:"ready"},[I.d.ERROR]:{Icon:O.a,className:"error"},[I.d.DISABLED]:{Icon:R.a,className:"disabled"},[I.d.NOT_SUPPORTED]:{Icon:R.a,className:"alert"}});function U(e){const n=e.status,t=e.language,i=e.showAutocompleteStatus,o=e.tooltipPosition,r=e.t,a={height:"1em",width:"1em"},s=D[n],d=r("autocomplete."+n,{language:t}),c=r(`autocomplete.${n}_tooltip`,{language:t});return l.a.createElement("span",{className:"autocomplete-status","data-lsp-state":n,"aria-atomic":"true",role:"status"},i?l.a.createElement("i",{className:"autocomplete-status--"+s.className},l.a.createElement(s.Icon,S()({},a,{"aria-label":s.className+" icon"}))):null,l.a.createElement("span",{className:"autocomplete-status__text"},d),l.a.createElement(N.a,{content:c,align:o},l.a.createElement(_.a,S()({},a,{tabIndex:0,"aria-label":"Info icon",role:"button"}))))}U.defaultProps={status:I.d.NOT_SUPPORTED,t:u.k,showAutocompleteStatus:!1,tooltipPosition:"bottom"};var B=t("9l/z"),j=t("zhsW"),F=t("ykP2"),M={"net.d.ts":'\ndeclare module \'node:net\' {\n    export * from \'net\';\n}\n\ndeclare module \'net\' {\n    import * as stream from \'node:stream\';\n    import EventEmitter = require(\'node:events\');\n    import * as dns from \'node:dns\';\n\n    type LookupFunction = (\n        hostname: string,\n        options: dns.LookupOneOptions,\n        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,\n    ) => void;\n\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface SocketConstructorOpts {\n        fd?: number;\n        allowHalfOpen?: boolean;\n        readable?: boolean;\n        writable?: boolean;\n    }\n\n    interface OnReadOpts {\n        buffer: Uint8Array | (() => Uint8Array);\n        /**\n         * This function is called for every chunk of incoming data.\n         * Two arguments are passed to it: the number of bytes written to buffer and a reference to buffer.\n         * Return false from this function to implicitly pause() the socket.\n         */\n        callback(bytesWritten: number, buf: Uint8Array): boolean;\n    }\n\n    interface ConnectOpts {\n        /**\n         * If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.\n         * Note: this will cause the streaming functionality to not provide any data, however events like \'error\', \'end\', and \'close\' will\n         * still be emitted as normal and methods like pause() and resume() will also behave as expected.\n         */\n        onread?: OnReadOpts;\n    }\n\n    interface TcpSocketConnectOpts extends ConnectOpts {\n        port: number;\n        host?: string;\n        localAddress?: string;\n        localPort?: number;\n        hints?: number;\n        family?: number;\n        lookup?: LookupFunction;\n    }\n\n    interface IpcSocketConnectOpts extends ConnectOpts {\n        path: string;\n    }\n\n    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\n\n    class Socket extends stream.Duplex {\n        constructor(options?: SocketConstructorOpts);\n\n        // Extended base methods\n        write(buffer: Uint8Array | string, cb?: (err?: Error) => void): boolean;\n        write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error) => void): boolean;\n\n        connect(options: SocketConnectOpts, connectionListener?: () => void): this;\n        connect(port: number, host: string, connectionListener?: () => void): this;\n        connect(port: number, connectionListener?: () => void): this;\n        connect(path: string, connectionListener?: () => void): this;\n\n        setEncoding(encoding?: BufferEncoding): this;\n        pause(): this;\n        resume(): this;\n        setTimeout(timeout: number, callback?: () => void): this;\n        setNoDelay(noDelay?: boolean): this;\n        setKeepAlive(enable?: boolean, initialDelay?: number): this;\n        address(): AddressInfo | {};\n        unref(): this;\n        ref(): this;\n\n        /** @deprecated since v14.6.0 - Use `writableLength` instead. */\n        readonly bufferSize: number;\n        readonly bytesRead: number;\n        readonly bytesWritten: number;\n        readonly connecting: boolean;\n        readonly destroyed: boolean;\n        readonly localAddress: string;\n        readonly localPort: number;\n        readonly remoteAddress?: string;\n        readonly remoteFamily?: string;\n        readonly remotePort?: number;\n\n        // Extended base methods\n        end(cb?: () => void): void;\n        end(buffer: Uint8Array | string, cb?: () => void): void;\n        end(str: Uint8Array | string, encoding?: BufferEncoding, cb?: () => void): void;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connect\n         *   3. data\n         *   4. drain\n         *   5. end\n         *   6. error\n         *   7. lookup\n         *   8. timeout\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: (had_error: boolean) => void): this;\n        addListener(event: "connect", listener: () => void): this;\n        addListener(event: "data", listener: (data: Buffer) => void): this;\n        addListener(event: "drain", listener: () => void): this;\n        addListener(event: "end", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        addListener(event: "timeout", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close", had_error: boolean): boolean;\n        emit(event: "connect"): boolean;\n        emit(event: "data", data: Buffer): boolean;\n        emit(event: "drain"): boolean;\n        emit(event: "end"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "lookup", err: Error, address: string, family: string | number, host: string): boolean;\n        emit(event: "timeout"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: (had_error: boolean) => void): this;\n        on(event: "connect", listener: () => void): this;\n        on(event: "data", listener: (data: Buffer) => void): this;\n        on(event: "drain", listener: () => void): this;\n        on(event: "end", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        on(event: "timeout", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: (had_error: boolean) => void): this;\n        once(event: "connect", listener: () => void): this;\n        once(event: "data", listener: (data: Buffer) => void): this;\n        once(event: "drain", listener: () => void): this;\n        once(event: "end", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        once(event: "timeout", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: (had_error: boolean) => void): this;\n        prependListener(event: "connect", listener: () => void): this;\n        prependListener(event: "data", listener: (data: Buffer) => void): this;\n        prependListener(event: "drain", listener: () => void): this;\n        prependListener(event: "end", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependListener(event: "timeout", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: (had_error: boolean) => void): this;\n        prependOnceListener(event: "connect", listener: () => void): this;\n        prependOnceListener(event: "data", listener: (data: Buffer) => void): this;\n        prependOnceListener(event: "drain", listener: () => void): this;\n        prependOnceListener(event: "end", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependOnceListener(event: "timeout", listener: () => void): this;\n    }\n\n    interface ListenOptions {\n        port?: number;\n        host?: string;\n        backlog?: number;\n        path?: string;\n        exclusive?: boolean;\n        readableAll?: boolean;\n        writableAll?: boolean;\n        /**\n         * @default false\n         */\n        ipv6Only?: boolean;\n    }\n\n    interface ServerOpts {\n        /**\n         * Indicates whether half-opened TCP connections are allowed. __Default:__ `false`.\n         */\n        allowHalfOpen?: boolean;\n\n        /**\n         * Indicates whether the socket should be paused on incoming connections. __Default:__ `false`.\n         */\n        pauseOnConnect?: boolean;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js\n    class Server extends EventEmitter {\n        constructor(connectionListener?: (socket: Socket) => void);\n        constructor(options?: ServerOpts, connectionListener?: (socket: Socket) => void);\n\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, hostname?: string, listeningListener?: () => void): this;\n        listen(port?: number, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, listeningListener?: () => void): this;\n        listen(path: string, backlog?: number, listeningListener?: () => void): this;\n        listen(path: string, listeningListener?: () => void): this;\n        listen(options: ListenOptions, listeningListener?: () => void): this;\n        listen(handle: any, backlog?: number, listeningListener?: () => void): this;\n        listen(handle: any, listeningListener?: () => void): this;\n        close(callback?: (err?: Error) => void): this;\n        address(): AddressInfo | string | null;\n        getConnections(cb: (error: Error | null, count: number) => void): void;\n        ref(): this;\n        unref(): this;\n        maxConnections: number;\n        connections: number;\n        listening: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connection\n         *   3. error\n         *   4. listening\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "connection", listener: (socket: Socket) => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "listening", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "connection", socket: Socket): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "listening"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "connection", listener: (socket: Socket) => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "listening", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "connection", listener: (socket: Socket) => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "listening", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "connection", listener: (socket: Socket) => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "listening", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "listening", listener: () => void): this;\n    }\n\n    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\n\n    function createServer(connectionListener?: (socket: Socket) => void): Server;\n    function createServer(options?: ServerOpts, connectionListener?: (socket: Socket) => void): Server;\n    function connect(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function connect(port: number, host?: string, connectionListener?: () => void): Socket;\n    function connect(path: string, connectionListener?: () => void): Socket;\n    function createConnection(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function createConnection(port: number, host?: string, connectionListener?: () => void): Socket;\n    function createConnection(path: string, connectionListener?: () => void): Socket;\n    function isIP(input: string): number;\n    function isIPv4(input: string): boolean;\n    function isIPv6(input: string): boolean;\n}',"process.d.ts":'\ndeclare module \'node:process\' {\n    export = process;\n}\n\ndeclare module \'process\' {\n    import * as tty from \'node:tty\';\n\n    global {\n        var process: NodeJS.Process;\n\n        namespace NodeJS {\n            // this namespace merge is here because these are specifically used\n            // as the type for process.stdin, process.stdout, and process.stderr.\n            // they can\'t live in tty.d.ts because we need to disambiguate the imported name.\n            interface ReadStream extends tty.ReadStream {}\n            interface WriteStream extends tty.WriteStream {}\n\n            interface MemoryUsage {\n                rss: number;\n                heapTotal: number;\n                heapUsed: number;\n                external: number;\n                arrayBuffers: number;\n            }\n\n            interface CpuUsage {\n                user: number;\n                system: number;\n            }\n\n            interface ProcessRelease {\n                name: string;\n                sourceUrl?: string;\n                headersUrl?: string;\n                libUrl?: string;\n                lts?: string;\n            }\n\n            interface ProcessVersions extends Dict<string> {\n                http_parser: string;\n                node: string;\n                v8: string;\n                ares: string;\n                uv: string;\n                zlib: string;\n                modules: string;\n                openssl: string;\n            }\n\n            type Platform = \'aix\'\n                | \'android\'\n                | \'darwin\'\n                | \'freebsd\'\n                | \'linux\'\n                | \'openbsd\'\n                | \'sunos\'\n                | \'win32\'\n                | \'cygwin\'\n                | \'netbsd\';\n\n            type Signals =\n                "SIGABRT" | "SIGALRM" | "SIGBUS" | "SIGCHLD" | "SIGCONT" | "SIGFPE" | "SIGHUP" | "SIGILL" | "SIGINT" | "SIGIO" |\n                "SIGIOT" | "SIGKILL" | "SIGPIPE" | "SIGPOLL" | "SIGPROF" | "SIGPWR" | "SIGQUIT" | "SIGSEGV" | "SIGSTKFLT" |\n                "SIGSTOP" | "SIGSYS" | "SIGTERM" | "SIGTRAP" | "SIGTSTP" | "SIGTTIN" | "SIGTTOU" | "SIGUNUSED" | "SIGURG" |\n                "SIGUSR1" | "SIGUSR2" | "SIGVTALRM" | "SIGWINCH" | "SIGXCPU" | "SIGXFSZ" | "SIGBREAK" | "SIGLOST" | "SIGINFO";\n\n            type MultipleResolveType = \'resolve\' | \'reject\';\n\n            type BeforeExitListener = (code: number) => void;\n            type DisconnectListener = () => void;\n            type ExitListener = (code: number) => void;\n            type RejectionHandledListener = (promise: Promise<any>) => void;\n            type UncaughtExceptionListener = (error: Error) => void;\n            type UnhandledRejectionListener = (reason: {} | null | undefined, promise: Promise<any>) => void;\n            type WarningListener = (warning: Error) => void;\n            type MessageListener = (message: any, sendHandle: any) => void;\n            type SignalsListener = (signal: Signals) => void;\n            type NewListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n            type RemoveListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n            type MultipleResolveListener = (type: MultipleResolveType, promise: Promise<any>, value: any) => void;\n\n            interface Socket extends ReadWriteStream {\n                isTTY?: true;\n            }\n\n            // Alias for compatibility\n            interface ProcessEnv extends Dict<string> {}\n\n            interface HRTime {\n                (time?: [number, number]): [number, number];\n                bigint(): bigint;\n            }\n\n            interface ProcessReport {\n                /**\n                 * Directory where the report is written.\n                 * working directory of the Node.js process.\n                 * @default \'\' indicating that reports are written to the current\n                 */\n                directory: string;\n\n                /**\n                 * Filename where the report is written.\n                 * The default value is the empty string.\n                 * @default \'\' the output filename will be comprised of a timestamp,\n                 * PID, and sequence number.\n                 */\n                filename: string;\n\n                /**\n                 * Returns a JSON-formatted diagnostic report for the running process.\n                 * The report\'s JavaScript stack trace is taken from err, if present.\n                 */\n                getReport(err?: Error): string;\n\n                /**\n                 * If true, a diagnostic report is generated on fatal errors,\n                 * such as out of memory errors or failed C++ assertions.\n                 * @default false\n                 */\n                reportOnFatalError: boolean;\n\n                /**\n                 * If true, a diagnostic report is generated when the process\n                 * receives the signal specified by process.report.signal.\n                 * @defaul false\n                 */\n                reportOnSignal: boolean;\n\n                /**\n                 * If true, a diagnostic report is generated on uncaught exception.\n                 * @default false\n                 */\n                reportOnUncaughtException: boolean;\n\n                /**\n                 * The signal used to trigger the creation of a diagnostic report.\n                 * @default \'SIGUSR2\'\n                 */\n                signal: Signals;\n\n                /**\n                 * Writes a diagnostic report to a file. If filename is not provided, the default filename\n                 * includes the date, time, PID, and a sequence number.\n                 * The report\'s JavaScript stack trace is taken from err, if present.\n                 *\n                 * @param fileName Name of the file where the report is written.\n                 * This should be a relative path, that will be appended to the directory specified in\n                 * `process.report.directory`, or the current working directory of the Node.js process,\n                 * if unspecified.\n                 * @param error A custom error used for reporting the JavaScript stack.\n                 * @return Filename of the generated report.\n                 */\n                writeReport(fileName?: string): string;\n                writeReport(error?: Error): string;\n                writeReport(fileName?: string, err?: Error): string;\n            }\n\n            interface ResourceUsage {\n                fsRead: number;\n                fsWrite: number;\n                involuntaryContextSwitches: number;\n                ipcReceived: number;\n                ipcSent: number;\n                majorPageFault: number;\n                maxRSS: number;\n                minorPageFault: number;\n                sharedMemorySize: number;\n                signalsCount: number;\n                swappedOut: number;\n                systemCPUTime: number;\n                unsharedDataSize: number;\n                unsharedStackSize: number;\n                userCPUTime: number;\n                voluntaryContextSwitches: number;\n            }\n\n            interface Process extends EventEmitter {\n                /**\n                 * Can also be a tty.WriteStream, not typed due to limitations.\n                 */\n                stdout: WriteStream & {\n                    fd: 1;\n                };\n                /**\n                 * Can also be a tty.WriteStream, not typed due to limitations.\n                 */\n                stderr: WriteStream & {\n                    fd: 2;\n                };\n                stdin: ReadStream & {\n                    fd: 0;\n                };\n                openStdin(): Socket;\n                argv: string[];\n                argv0: string;\n                execArgv: string[];\n                execPath: string;\n                abort(): never;\n                chdir(directory: string): void;\n                cwd(): string;\n                debugPort: number;\n                emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\n                env: ProcessEnv;\n                exit(code?: number): never;\n                exitCode?: number;\n                getgid(): number;\n                setgid(id: number | string): void;\n                getuid(): number;\n                setuid(id: number | string): void;\n                geteuid(): number;\n                seteuid(id: number | string): void;\n                getegid(): number;\n                setegid(id: number | string): void;\n                getgroups(): number[];\n                setgroups(groups: ReadonlyArray<string | number>): void;\n                setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;\n                hasUncaughtExceptionCaptureCallback(): boolean;\n                version: string;\n                versions: ProcessVersions;\n                config: {\n                    target_defaults: {\n                        cflags: any[];\n                        default_configuration: string;\n                        defines: string[];\n                        include_dirs: string[];\n                        libraries: string[];\n                    };\n                    variables: {\n                        clang: number;\n                        host_arch: string;\n                        node_install_npm: boolean;\n                        node_install_waf: boolean;\n                        node_prefix: string;\n                        node_shared_openssl: boolean;\n                        node_shared_v8: boolean;\n                        node_shared_zlib: boolean;\n                        node_use_dtrace: boolean;\n                        node_use_etw: boolean;\n                        node_use_openssl: boolean;\n                        target_arch: string;\n                        v8_no_strict_aliasing: number;\n                        v8_use_snapshot: boolean;\n                        visibility: string;\n                    };\n                };\n                kill(pid: number, signal?: string | number): true;\n                pid: number;\n                ppid: number;\n                title: string;\n                arch: string;\n                platform: Platform;\n                /** @deprecated since v14.0.0 - use `require.main` instead. */\n                mainModule?: Module;\n                memoryUsage(): MemoryUsage;\n                cpuUsage(previousValue?: CpuUsage): CpuUsage;\n                nextTick(callback: Function, ...args: any[]): void;\n                release: ProcessRelease;\n                features: {\n                    inspector: boolean;\n                    debug: boolean;\n                    uv: boolean;\n                    ipv6: boolean;\n                    tls_alpn: boolean;\n                    tls_sni: boolean;\n                    tls_ocsp: boolean;\n                    tls: boolean;\n                };\n                /**\n                 * @deprecated since v14.0.0 - Calling process.umask() with no argument causes\n                 * the process-wide umask to be written twice. This introduces a race condition between threads,\n                 * and is a potential security vulnerability. There is no safe, cross-platform alternative API.\n                 */\n                umask(): number;\n                /**\n                 * Can only be set if not in worker thread.\n                 */\n                umask(mask: string | number): number;\n                uptime(): number;\n                hrtime: HRTime;\n                domain: Domain;\n\n                // Worker\n                send?(message: any, sendHandle?: any, options?: { swallowErrors?: boolean}, callback?: (error: Error | null) => void): boolean;\n                disconnect(): void;\n                connected: boolean;\n\n                /**\n                 * The `process.allowedNodeEnvironmentFlags` property is a special,\n                 * read-only `Set` of flags allowable within the [`NODE_OPTIONS`][]\n                 * environment variable.\n                 */\n                allowedNodeEnvironmentFlags: ReadonlySet<string>;\n\n                /**\n                 * Only available with `--experimental - report`\n                 */\n                report?: ProcessReport;\n\n                resourceUsage(): ResourceUsage;\n\n                traceDeprecation: boolean;\n\n                /* EventEmitter */\n                addListener(event: "beforeExit", listener: BeforeExitListener): this;\n                addListener(event: "disconnect", listener: DisconnectListener): this;\n                addListener(event: "exit", listener: ExitListener): this;\n                addListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                addListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                addListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                addListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                addListener(event: "warning", listener: WarningListener): this;\n                addListener(event: "message", listener: MessageListener): this;\n                addListener(event: Signals, listener: SignalsListener): this;\n                addListener(event: "newListener", listener: NewListenerListener): this;\n                addListener(event: "removeListener", listener: RemoveListenerListener): this;\n                addListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                emit(event: "beforeExit", code: number): boolean;\n                emit(event: "disconnect"): boolean;\n                emit(event: "exit", code: number): boolean;\n                emit(event: "rejectionHandled", promise: Promise<any>): boolean;\n                emit(event: "uncaughtException", error: Error): boolean;\n                emit(event: "uncaughtExceptionMonitor", error: Error): boolean;\n                emit(event: "unhandledRejection", reason: any, promise: Promise<any>): boolean;\n                emit(event: "warning", warning: Error): boolean;\n                emit(event: "message", message: any, sendHandle: any): this;\n                emit(event: Signals, signal: Signals): boolean;\n                emit(event: "newListener", eventName: string | symbol, listener: (...args: any[]) => void): this;\n                emit(event: "removeListener", eventName: string, listener: (...args: any[]) => void): this;\n                emit(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                on(event: "beforeExit", listener: BeforeExitListener): this;\n                on(event: "disconnect", listener: DisconnectListener): this;\n                on(event: "exit", listener: ExitListener): this;\n                on(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                on(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                on(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                on(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                on(event: "warning", listener: WarningListener): this;\n                on(event: "message", listener: MessageListener): this;\n                on(event: Signals, listener: SignalsListener): this;\n                on(event: "newListener", listener: NewListenerListener): this;\n                on(event: "removeListener", listener: RemoveListenerListener): this;\n                on(event: "multipleResolves", listener: MultipleResolveListener): this;\n                on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n                once(event: "beforeExit", listener: BeforeExitListener): this;\n                once(event: "disconnect", listener: DisconnectListener): this;\n                once(event: "exit", listener: ExitListener): this;\n                once(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                once(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                once(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                once(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                once(event: "warning", listener: WarningListener): this;\n                once(event: "message", listener: MessageListener): this;\n                once(event: Signals, listener: SignalsListener): this;\n                once(event: "newListener", listener: NewListenerListener): this;\n                once(event: "removeListener", listener: RemoveListenerListener): this;\n                once(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                prependListener(event: "beforeExit", listener: BeforeExitListener): this;\n                prependListener(event: "disconnect", listener: DisconnectListener): this;\n                prependListener(event: "exit", listener: ExitListener): this;\n                prependListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                prependListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                prependListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                prependListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                prependListener(event: "warning", listener: WarningListener): this;\n                prependListener(event: "message", listener: MessageListener): this;\n                prependListener(event: Signals, listener: SignalsListener): this;\n                prependListener(event: "newListener", listener: NewListenerListener): this;\n                prependListener(event: "removeListener", listener: RemoveListenerListener): this;\n                prependListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                prependOnceListener(event: "beforeExit", listener: BeforeExitListener): this;\n                prependOnceListener(event: "disconnect", listener: DisconnectListener): this;\n                prependOnceListener(event: "exit", listener: ExitListener): this;\n                prependOnceListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                prependOnceListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                prependOnceListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                prependOnceListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                prependOnceListener(event: "warning", listener: WarningListener): this;\n                prependOnceListener(event: "message", listener: MessageListener): this;\n                prependOnceListener(event: Signals, listener: SignalsListener): this;\n                prependOnceListener(event: "newListener", listener: NewListenerListener): this;\n                prependOnceListener(event: "removeListener", listener: RemoveListenerListener): this;\n                prependOnceListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                listeners(event: "beforeExit"): BeforeExitListener[];\n                listeners(event: "disconnect"): DisconnectListener[];\n                listeners(event: "exit"): ExitListener[];\n                listeners(event: "rejectionHandled"): RejectionHandledListener[];\n                listeners(event: "uncaughtException"): UncaughtExceptionListener[];\n                listeners(event: "uncaughtExceptionMonitor"): UncaughtExceptionListener[];\n                listeners(event: "unhandledRejection"): UnhandledRejectionListener[];\n                listeners(event: "warning"): WarningListener[];\n                listeners(event: "message"): MessageListener[];\n                listeners(event: Signals): SignalsListener[];\n                listeners(event: "newListener"): NewListenerListener[];\n                listeners(event: "removeListener"): RemoveListenerListener[];\n                listeners(event: "multipleResolves"): MultipleResolveListener[];\n            }\n\n            interface Global {\n                process: Process;\n            }\n        }\n    }\n\n    export = process;\n}',"tty.d.ts":'\ndeclare module \'node:tty\' {\n    export * from \'tty\';\n}\n\ndeclare module \'tty\' {\n    import * as net from \'node:net\';\n\n    function isatty(fd: number): boolean;\n    class ReadStream extends net.Socket {\n        constructor(fd: number, options?: net.SocketConstructorOpts);\n        isRaw: boolean;\n        setRawMode(mode: boolean): this;\n        isTTY: boolean;\n    }\n    /**\n     * -1 - to the left from cursor\n     *  0 - the entire line\n     *  1 - to the right from cursor\n     */\n    type Direction = -1 | 0 | 1;\n    class WriteStream extends net.Socket {\n        constructor(fd: number);\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "resize", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "resize"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "resize", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "resize", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "resize", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "resize", listener: () => void): this;\n\n        /**\n         * Clears the current line of this WriteStream in a direction identified by `dir`.\n         */\n        clearLine(dir: Direction, callback?: () => void): boolean;\n        /**\n         * Clears this `WriteStream` from the current cursor down.\n         */\n        clearScreenDown(callback?: () => void): boolean;\n        /**\n         * Moves this WriteStream\'s cursor to the specified position.\n         */\n        cursorTo(x: number, y?: number, callback?: () => void): boolean;\n        cursorTo(x: number, callback: () => void): boolean;\n        /**\n         * Moves this WriteStream\'s cursor relative to its current position.\n         */\n        moveCursor(dx: number, dy: number, callback?: () => void): boolean;\n        /**\n         * @default `process.env`\n         */\n        getColorDepth(env?: {}): number;\n        hasColors(depth?: number): boolean;\n        hasColors(env?: {}): boolean;\n        hasColors(depth: number, env?: {}): boolean;\n        getWindowSize(): [number, number];\n        columns: number;\n        rows: number;\n        isTTY: boolean;\n    }\n}',"fs.d.ts":"declare module \"fs\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import { URL } from \"url\";\n\n    /**\n     * Valid types for path values in \"fs\".\n     */\n    type PathLike = string | Buffer | URL;\n\n    type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;\n\n    interface StatsBase<T> {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n\n        dev: T;\n        ino: T;\n        mode: T;\n        nlink: T;\n        uid: T;\n        gid: T;\n        rdev: T;\n        size: T;\n        blksize: T;\n        blocks: T;\n        atimeMs: T;\n        mtimeMs: T;\n        ctimeMs: T;\n        birthtimeMs: T;\n        atime: Date;\n        mtime: Date;\n        ctime: Date;\n        birthtime: Date;\n    }\n\n    interface Stats extends StatsBase<number> {\n    }\n\n    class Stats {\n    }\n\n    class Dirent {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        name: string;\n    }\n\n    /**\n     * A class representing a directory stream.\n     */\n    class Dir {\n        readonly path: string;\n\n        /**\n         * Asynchronously iterates over the directory via 'readdir(3)' until all entries have been read.\n         */\n        [Symbol.asyncIterator](): AsyncIterableIterator<Dirent>;\n\n        /**\n         * Asynchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         */\n        close(): Promise<void>;\n        close(cb: NoParamCallback): void;\n\n        /**\n         * Synchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         */\n        closeSync(): void;\n\n        /**\n         * Asynchronously read the next directory entry via 'readdir(3)' as an 'Dirent'.\n         * After the read is completed, a value is returned that will be resolved with an 'Dirent', or 'null' if there are no more directory entries to read.\n         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.\n         */\n        read(): Promise<Dirent | null>;\n        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;\n\n        /**\n         * Synchronously read the next directory entry via 'readdir(3)' as a 'Dirent'.\n         * If there are no more directory entries to read, null will be returned.\n         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.\n         */\n        readSync(): Dirent;\n    }\n\n    interface FSWatcher extends events.EventEmitter {\n        close(): void;\n\n        /**\n         * events.EventEmitter\n         *   1. change\n         *   2. error\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"close\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"close\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n    }\n\n    class ReadStream extends stream.Readable {\n        close(): void;\n        bytesRead: number;\n        path: string | Buffer;\n        pending: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"readable\", listener: () => void): this;\n        addListener(event: \"ready\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"readable\", listener: () => void): this;\n        on(event: \"ready\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"readable\", listener: () => void): this;\n        once(event: \"ready\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"readable\", listener: () => void): this;\n        prependListener(event: \"ready\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"readable\", listener: () => void): this;\n        prependOnceListener(event: \"ready\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    class WriteStream extends stream.Writable {\n        close(): void;\n        bytesWritten: number;\n        path: string | Buffer;\n        pending: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"ready\", listener: () => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"ready\", listener: () => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"ready\", listener: () => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"ready\", listener: () => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"ready\", listener: () => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    /**\n     * Asynchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rename {\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function renameSync(oldPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param len If not specified, defaults to '0'.\n     */\n    function truncate(path: PathLike, len: number | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function truncate(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace truncate {\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param len If not specified, defaults to '0'.\n         */\n        function __promisify__(path: PathLike, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param len If not specified, defaults to '0'.\n     */\n    function truncateSync(path: PathLike, len?: number | null): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to '0'.\n     */\n    function ftruncate(fd: number, len: number | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     */\n    function ftruncate(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace ftruncate {\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param fd A file descriptor.\n         * @param len If not specified, defaults to '0'.\n         */\n        function __promisify__(fd: number, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to '0'.\n     */\n    function ftruncateSync(fd: number, len?: number | null): void;\n\n    /**\n     * Asynchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chown {\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function chownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchown {\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchownSync(fd: number, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchown {\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lchownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chmod {\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmod(fd: number, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchmod {\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param fd A file descriptor.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(fd: number, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmodSync(fd: number, mode: string | number): void;\n\n    /**\n     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchmod {\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function stat(path: PathLike, options: StatOptions & { bigint?: false } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function stat(path: PathLike, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;\n    function stat(path: PathLike, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace stat {\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, options?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function __promisify__(path: PathLike, options: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n\n    /**\n     * Synchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function statSync(path: PathLike, options?: StatOptions & { bigint?: false }): Stats;\n    function statSync(path: PathLike, options: StatOptions & { bigint: true }): BigIntStats;\n    function statSync(path: PathLike, options?: StatOptions): Stats | BigIntStats;\n\n    /**\n     * Asynchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function fstat(fd: number, options: StatOptions & { bigint?: false } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function fstat(fd: number, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;\n    function fstat(fd: number, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fstat {\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, options?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function __promisify__(fd: number, options: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n\n    /**\n     * Synchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstatSync(fd: number, options?: StatOptions & { bigint?: false }): Stats;\n    function fstatSync(fd: number, options: StatOptions & { bigint: true }): BigIntStats;\n    function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;\n\n    /**\n     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function lstat(path: PathLike, options: StatOptions & { bigint?: false } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function lstat(path: PathLike, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;\n    function lstat(path: PathLike, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lstat {\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, options?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function __promisify__(path: PathLike, options: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n\n    /**\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lstatSync(path: PathLike, options?: StatOptions & { bigint?: false }): Stats;\n    function lstatSync(path: PathLike, options: StatOptions & { bigint: true }): BigIntStats;\n    function lstatSync(path: PathLike, options?: StatOptions): Stats | BigIntStats;\n\n    /**\n     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace link {\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function linkSync(existingPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n     * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n     * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n     */\n    function symlink(target: PathLike, path: PathLike, type: symlink.Type | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace symlink {\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n         * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n         * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n         */\n        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        type Type = \"dir\" | \"file\" | \"junction\";\n    }\n\n    /**\n     * Synchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n     * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n     * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n     */\n    function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlink(\n        path: PathLike,\n        options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void\n    ): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException | null, linkString: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readlink {\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlinkSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpath(\n        path: PathLike,\n        options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void\n    ): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace realpath {\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        function native(\n            path: PathLike,\n            options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void\n        ): void;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;\n        function native(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void): void;\n        function native(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;\n    }\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpathSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    namespace realpathSync {\n        function native(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n        function native(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n    }\n\n    /**\n     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function unlink(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace unlink {\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function unlinkSync(path: PathLike): void;\n\n    interface RmDirOptions {\n        /**\n         * If an 'EBUSY', 'EMFILE', 'ENFILE', 'ENOTEMPTY', or\n         * 'EPERM' error is encountered, Node.js will retry the operation with a linear\n         * backoff wait of 'retryDelay' ms longer on each try. This option represents the\n         * number of retries. This option is ignored if the 'recursive' option is not\n         * 'true'.\n         * @default 0\n         */\n        maxRetries?: number;\n        /**\n         * If 'true', perform a recursive directory removal. In\n         * recursive mode, errors are not reported if 'path' does not exist, and\n         * operations are retried on failure.\n         * @experimental\n         * @default false\n         */\n        recursive?: boolean;\n        /**\n         * The amount of time in milliseconds to wait between retries.\n         * This option is ignored if the 'recursive' option is not 'true'.\n         * @default 100\n         */\n        retryDelay?: number;\n    }\n\n    /**\n     * Asynchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function rmdir(path: PathLike, callback: NoParamCallback): void;\n    function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rmdir {\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function rmdirSync(path: PathLike, options?: RmDirOptions): void;\n\n    interface MakeDirectoryOptions {\n        /**\n         * Indicates whether parent folders should be created.\n         * If a folder was created, the path to the first created folder will be returned.\n         * @default false\n         */\n        recursive?: boolean;\n        /**\n         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified\n         * @default 0o777\n         */\n        mode?: number | string;\n    }\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdir(path: PathLike, options: MakeDirectoryOptions & { recursive: true }, callback: (err: NodeJS.ErrnoException | null, path?: string) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdir(path: PathLike, options: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null | undefined, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdir(path: PathLike, options: number | string | MakeDirectoryOptions | null | undefined, callback: (err: NodeJS.ErrnoException | null, path?: string) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory with a mode of '0o777'.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function mkdir(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdir {\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function __promisify__(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): Promise<string | undefined>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function __promisify__(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function __promisify__(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<string | undefined>;\n    }\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdirSync(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): string | undefined;\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdirSync(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): void;\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdirSync(path: PathLike, options?: number | string | MakeDirectoryOptions | null): string | undefined;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, folder: string) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtemp(prefix: string, options: \"buffer\" | { encoding: \"buffer\" }, callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     */\n    function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException | null, folder: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdtemp {\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtempSync(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding?: string | null; withFileTypes?: false } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException | null, files: string[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent.\n     */\n    function readdir(path: PathLike, options: { encoding?: string | null; withFileTypes: true }, callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readdir {\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options: \"buffer\" | { encoding: \"buffer\"; withFileTypes?: false }): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent\n         */\n        function __promisify__(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Promise<Dirent[]>;\n    }\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): string[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdirSync(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): string[] | Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent.\n     */\n    function readdirSync(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Dirent[];\n\n    /**\n     * Asynchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function close(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace close {\n        /**\n         * Asynchronous close(2) - close a file descriptor.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function closeSync(fd: number): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to '0o666'.\n     */\n    function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be '0o666'.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace open {\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to '0o666'.\n         */\n        function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;\n    }\n\n    /**\n     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to '0o666'.\n     */\n    function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace utimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace futimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsync(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fsync {\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsyncSync(fd: number): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void\n    ): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function write(\n        fd: number,\n        string: any,\n        position: number | undefined | null,\n        encoding: string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;\n\n    /**\n     * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     */\n    function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace write {\n        /**\n         * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n         * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer?: TBuffer,\n            offset?: number,\n            length?: number,\n            position?: number | null,\n        ): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n    }\n\n    /**\n     * Synchronously writes 'buffer' to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function writeSync(fd: number, buffer: NodeJS.ArrayBufferView, offset?: number | null, length?: number | null, position?: number | null): number;\n\n    /**\n     * Synchronously writes 'string' to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;\n\n    /**\n     * Asynchronously reads data from the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n     */\n    function read<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number,\n        length: number,\n        position: number | null,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace read {\n        /**\n         * @param fd A file descriptor.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer: TBuffer,\n            offset: number,\n            length: number,\n            position: number | null\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n    }\n\n    interface ReadSyncOptions {\n        /**\n         * @default 0\n         */\n        offset?: number;\n        /**\n         * @default 'length of buffer'\n         */\n        length?: number;\n        /**\n         * @default null\n         */\n        position?: number | null;\n    }\n\n    /**\n     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n     */\n    function readSync(fd: number, buffer: NodeJS.ArrayBufferView, offset: number, length: number, position: number | null): number;\n\n    /**\n     * Similar to the above 'fs.readSync' function, this version takes an optional 'options' object.\n     * If no 'options' object is specified, it will default with the above values.\n     */\n    function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFile(path: PathLike | number, options: { encoding?: null; flag?: string; } | undefined | null, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFile(path: PathLike | number, options: { encoding: string; flag?: string; } | string, callback: (err: NodeJS.ErrnoException | null, data: string) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFile(\n        path: PathLike | number,\n        options: { encoding?: string | null; flag?: string; } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, data: string | Buffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     */\n    function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readFile {\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string; } | string): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to ''r''.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Buffer;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string; } | string): string;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): string | Buffer;\n\n    type WriteFileOptions = { encoding?: string | null; mode?: number | string; flag?: string; } | string | null;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''w'' is used.\n     */\n    function writeFile(path: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function writeFile(path: PathLike | number, data: any, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace writeFile {\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''w'' is used.\n         */\n        function __promisify__(path: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''w'' is used.\n     */\n    function writeFileSync(path: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''a'' is used.\n     */\n    function appendFile(file: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function appendFile(file: PathLike | number, data: any, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace appendFile {\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''a'' is used.\n         */\n        function __promisify__(file: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''a'' is used.\n     */\n    function appendFileSync(file: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Watch for changes on 'filename'. The callback 'listener' will be called each time the file is accessed.\n     */\n    function watchFile(filename: PathLike, options: { persistent?: boolean; interval?: number; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on 'filename'. The callback 'listener' will be called each time the file is accessed.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Stop watching for changes on 'filename'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'persistent' is not supplied, the default of 'true' is used.\n     * If 'recursive' is not supplied, the default of 'false' is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: BufferEncoding | null, persistent?: boolean, recursive?: boolean } | BufferEncoding | undefined | null,\n        listener?: (event: string, filename: string) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'persistent' is not supplied, the default of 'true' is used.\n     * If 'recursive' is not supplied, the default of 'false' is used.\n     */\n    function watch(filename: PathLike, options: { encoding: \"buffer\", persistent?: boolean, recursive?: boolean } | \"buffer\", listener?: (event: string, filename: Buffer) => void): FSWatcher;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'persistent' is not supplied, the default of 'true' is used.\n     * If 'recursive' is not supplied, the default of 'false' is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: string | null, persistent?: boolean, recursive?: boolean } | string | null,\n        listener?: (event: string, filename: string | Buffer) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;\n\n    /**\n     * Asynchronously tests whether or not the given path exists by checking with the file system.\n     * @deprecated\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function exists(path: PathLike, callback: (exists: boolean) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exists {\n        /**\n         * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike): Promise<boolean>;\n    }\n\n    /**\n     * Synchronously tests whether or not the given path exists by checking with the file system.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function existsSync(path: PathLike): boolean;\n\n    namespace constants {\n        // File Access Constants\n\n        /** Constant for fs.access(). File is visible to the calling process. */\n        const F_OK: number;\n\n        /** Constant for fs.access(). File can be read by the calling process. */\n        const R_OK: number;\n\n        /** Constant for fs.access(). File can be written by the calling process. */\n        const W_OK: number;\n\n        /** Constant for fs.access(). File can be executed by the calling process. */\n        const X_OK: number;\n\n        // File Copy Constants\n\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\n        const COPYFILE_EXCL: number;\n\n        /**\n         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.\n         */\n        const COPYFILE_FICLONE: number;\n\n        /**\n         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.\n         */\n        const COPYFILE_FICLONE_FORCE: number;\n\n        // File Open Constants\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\n        const O_RDONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\n        const O_WRONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\n        const O_RDWR: number;\n\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\n        const O_CREAT: number;\n\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\n        const O_EXCL: number;\n\n        /**\n         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,\n         * opening the path shall not cause that terminal to become the controlling terminal for the process\n         * (if the process does not already have one).\n         */\n        const O_NOCTTY: number;\n\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\n        const O_TRUNC: number;\n\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\n        const O_APPEND: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\n        const O_DIRECTORY: number;\n\n        /**\n         * constant for fs.open().\n         * Flag indicating reading accesses to the file system will no longer result in\n         * an update to the atime information associated with the file.\n         * This flag is available on Linux operating systems only.\n         */\n        const O_NOATIME: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\n        const O_NOFOLLOW: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\n        const O_SYNC: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\n        const O_DSYNC: number;\n\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\n        const O_SYMLINK: number;\n\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\n        const O_DIRECT: number;\n\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\n        const O_NONBLOCK: number;\n\n        // File Type Constants\n\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\n        const S_IFMT: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\n        const S_IFREG: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\n        const S_IFDIR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\n        const S_IFCHR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\n        const S_IFBLK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\n        const S_IFIFO: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\n        const S_IFLNK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\n        const S_IFSOCK: number;\n\n        // File Mode Constants\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\n        const S_IRWXU: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\n        const S_IRUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\n        const S_IWUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\n        const S_IXUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\n        const S_IRWXG: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\n        const S_IRGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\n        const S_IWGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\n        const S_IXGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\n        const S_IRWXO: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\n        const S_IROTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\n        const S_IWOTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\n        const S_IXOTH: number;\n\n        /**\n         * When set, a memory file mapping is used to access the file. This flag\n         * is available on Windows operating systems only. On other operating systems,\n         * this flag is ignored.\n         */\n        const UV_FS_O_FILEMAP: number;\n    }\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace access {\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike, mode?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function accessSync(path: PathLike, mode?: number): void;\n\n    /**\n     * Returns a new 'ReadStream' object.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function createReadStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        /**\n         * @default false\n         */\n        emitClose?: boolean;\n        start?: number;\n        end?: number;\n        highWaterMark?: number;\n    }): ReadStream;\n\n    /**\n     * Returns a new 'WriteStream' object.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function createWriteStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        emitClose?: boolean;\n        start?: number;\n        highWaterMark?: number;\n    }): WriteStream;\n\n    /**\n     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasync(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fdatasync {\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasyncSync(fd: number): void;\n\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     */\n    function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFile(src: PathLike, dest: PathLike, flags: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace copyFile {\n        /**\n         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n         * No arguments other than a possible exception are given to the callback function.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation.\n         * The only supported flag is fs.constants.COPYFILE_EXCL,\n         * which causes the copy operation to fail if dest already exists.\n         */\n        function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An optional integer that specifies the behavior of the copy operation.\n     * The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;\n\n    /**\n     * Write an array of ArrayBufferViews to the file specified by fd using writev().\n     * position is the offset from the beginning of the file where this data should be written.\n     * It is unsafe to use fs.writev() multiple times on the same file without waiting for the callback. For this scenario, use fs.createWriteStream().\n     * On Linux, positional writes don't work when the file is opened in append mode.\n     * The kernel ignores the position argument and always appends the data to the end of the file.\n     */\n    function writev(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n    function writev(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        position: number,\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n\n    interface WriteVResult {\n        bytesWritten: number;\n        buffers: NodeJS.ArrayBufferView[];\n    }\n\n    namespace writev {\n        function __promisify__(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<WriteVResult>;\n    }\n\n    /**\n     * See 'writev'.\n     */\n    function writevSync(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): number;\n\n    function readv(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n    function readv(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        position: number,\n        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n\n    interface ReadVResult {\n        bytesRead: number;\n        buffers: NodeJS.ArrayBufferView[];\n    }\n\n    namespace readv {\n        function __promisify__(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<ReadVResult>;\n    }\n\n    /**\n     * See 'readv'.\n     */\n    function readvSync(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): number;\n\n    interface OpenDirOptions {\n        encoding?: BufferEncoding;\n        /**\n         * Number of directory entries that are buffered\n         * internally when reading from the directory. Higher values lead to better\n         * performance but higher memory usage.\n         * @default 32\n         */\n        bufferSize?: number;\n    }\n\n    function opendirSync(path: string, options?: OpenDirOptions): Dir;\n\n    function opendir(path: string, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;\n    function opendir(path: string, options: OpenDirOptions, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;\n\n    namespace opendir {\n        function __promisify__(path: string, options?: OpenDirOptions): Promise<Dir>;\n    }\n\n    namespace promises {\n        interface FileHandle {\n            /**\n             * Gets the file descriptor for this file handle.\n             */\n            readonly fd: number;\n\n            /**\n             * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for appending.\n             * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If 'encoding' is not supplied, the default of ''utf8'' is used.\n             * If 'mode' is not supplied, the default of '0o666' is used.\n             * If 'mode' is a string, it is parsed as an octal integer.\n             * If 'flag' is not supplied, the default of ''a'' is used.\n             */\n            appendFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous fchown(2) - Change ownership of a file.\n             */\n            chown(uid: number, gid: number): Promise<void>;\n\n            /**\n             * Asynchronous fchmod(2) - Change permissions of a file.\n             * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n             */\n            chmod(mode: string | number): Promise<void>;\n\n            /**\n             * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n             */\n            datasync(): Promise<void>;\n\n            /**\n             * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n             */\n            sync(): Promise<void>;\n\n            /**\n             * Asynchronously reads data from the file.\n             * The 'FileHandle' must have been opened for reading.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The offset in the buffer at which to start writing.\n             * @param length The number of bytes to read.\n             * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n             */\n            read<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to ''r''.\n             */\n            readFile(options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to ''r''.\n             */\n            readFile(options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to ''r''.\n             */\n            readFile(options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n            /**\n             * Asynchronous fstat(2) - Get file status.\n             */\n            stat(opts?: StatOptions & { bigint?: false }): Promise<Stats>;\n            stat(opts: StatOptions & { bigint: true }): Promise<BigIntStats>;\n            stat(opts?: StatOptions): Promise<Stats | BigIntStats>;\n\n            /**\n             * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n             * @param len If not specified, defaults to '0'.\n             */\n            truncate(len?: number): Promise<void>;\n\n            /**\n             * Asynchronously change file timestamps of the file.\n             * @param atime The last access time. If a string is provided, it will be coerced to number.\n             * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n             */\n            utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n            /**\n             * Asynchronously writes 'buffer' to the file.\n             * The 'FileHandle' must have been opened for writing.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n             * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             */\n            write<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously writes 'string' to the file.\n             * The 'FileHandle' must have been opened for writing.\n             * It is unsafe to call 'write()' multiple times on the same file without waiting for the 'Promise'\n             * to be resolved (or rejected). For this scenario, 'fs.createWriteStream' is strongly recommended.\n             * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             * @param encoding The expected string encoding.\n             */\n            write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n            /**\n             * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for writing.\n             * It is unsafe to call 'writeFile()' multiple times on the same file without waiting for the 'Promise' to be resolved (or rejected).\n             * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If 'encoding' is not supplied, the default of ''utf8'' is used.\n             * If 'mode' is not supplied, the default of '0o666' is used.\n             * If 'mode' is a string, it is parsed as an octal integer.\n             * If 'flag' is not supplied, the default of ''w'' is used.\n             */\n            writeFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * See 'fs.writev' promisified version.\n             */\n            writev(buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<WriteVResult>;\n\n            /**\n             * See 'fs.readv' promisified version.\n             */\n            readv(buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<ReadVResult>;\n\n            /**\n             * Asynchronous close(2) - close a 'FileHandle'.\n             */\n            close(): Promise<void>;\n        }\n\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function access(path: PathLike, mode?: number): Promise<void>;\n\n        /**\n         * Asynchronously copies 'src' to 'dest'. By default, 'dest' is overwritten if it already exists.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation. The only\n         * supported flag is 'fs.constants.COPYFILE_EXCL', which causes the copy operation to fail if\n         * 'dest' already exists.\n         */\n        function copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;\n\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not\n         * supplied, defaults to '0o666'.\n         */\n        function open(path: PathLike, flags: string | number, mode?: string | number): Promise<FileHandle>;\n\n        /**\n         * Asynchronously reads data from the file referenced by the supplied 'FileHandle'.\n         * @param handle A 'FileHandle'.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If\n         * 'null', data will be read from the current position.\n         */\n        function read<TBuffer extends Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes 'buffer' to the file referenced by the supplied 'FileHandle'.\n         * It is unsafe to call 'fsPromises.write()' multiple times on the same file without waiting for the 'Promise'\n         * to be resolved (or rejected). For this scenario, 'fs.createWriteStream' is strongly recommended.\n         * @param handle A 'FileHandle'.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n         * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function write<TBuffer extends Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes 'string' to the file referenced by the supplied 'FileHandle'.\n         * It is unsafe to call 'fsPromises.write()' multiple times on the same file without waiting for the 'Promise'\n         * to be resolved (or rejected). For this scenario, 'fs.createWriteStream' is strongly recommended.\n         * @param handle A 'FileHandle'.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function write(handle: FileHandle, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param len If not specified, defaults to '0'.\n         */\n        function truncate(path: PathLike, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param handle A 'FileHandle'.\n         * @param len If not specified, defaults to '0'.\n         */\n        function ftruncate(handle: FileHandle, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function rmdir(path: PathLike, options?: RmDirOptions): Promise<void>;\n\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param handle A 'FileHandle'.\n         */\n        function fdatasync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param handle A 'FileHandle'.\n         */\n        function fsync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function mkdir(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): Promise<string | undefined>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function mkdir(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function mkdir(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<string | undefined>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent.\n         */\n        function readdir(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Promise<Dirent[]>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n         * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n         * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n         */\n        function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function lstat(path: PathLike, opts?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function lstat(path: PathLike, opts: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function lstat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;\n\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function stat(path: PathLike, opts?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function stat(path: PathLike, opts: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function stat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;\n\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function unlink(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param handle A 'FileHandle'.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function fchmod(handle: FileHandle, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function chmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function lchmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function lchown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param handle A 'FileHandle'.\n         */\n        function fchown(handle: FileHandle, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function chown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied 'FileHandle'.\n         * @param handle A 'FileHandle'.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function futimes(handle: FileHandle, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required 'prefix' to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required 'prefix' to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function mkdtemp(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required 'prefix' to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * It is unsafe to call 'fsPromises.writeFile()' multiple times on the same file without waiting for the 'Promise' to be resolved (or rejected).\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''w'' is used.\n         */\n        function writeFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''a'' is used.\n         */\n        function appendFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function readFile(path: PathLike | FileHandle, options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n        function opendir(path: string, options?: OpenDirOptions): Promise<Dir>;\n    }\n\n    interface BigIntStats extends StatsBase<bigint> {\n    }\n\n    class BigIntStats {\n        atimeNs: bigint;\n        mtimeNs: bigint;\n        ctimeNs: bigint;\n        birthtimeNs: bigint;\n    }\n\n    interface BigIntOptions {\n        bigint: true;\n    }\n\n    interface StatOptions {\n        bigint: boolean;\n    }\n}","stream.d.ts":'declare module \'stream\' {\n    import EventEmitter = require(\'events\');\n\n    class internal extends EventEmitter {\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\n    }\n\n    namespace internal {\n        class Stream extends internal {\n            constructor(opts?: ReadableOptions);\n        }\n\n        interface ReadableOptions {\n            highWaterMark?: number;\n            encoding?: string;\n            objectMode?: boolean;\n            read?(this: Readable, size: number): void;\n            destroy?(this: Readable, error: Error | null, callback: (error: Error | null) => void): void;\n            autoDestroy?: boolean;\n        }\n\n        class Readable extends Stream implements NodeJS.ReadableStream {\n            /**\n             * A utility method for creating Readable Streams out of iterators.\n             */\n            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;\n\n            readable: boolean;\n            readonly readableEncoding: BufferEncoding | null;\n            readonly readableEnded: boolean;\n            readonly readableFlowing: boolean | null;\n            readonly readableHighWaterMark: number;\n            readonly readableLength: number;\n            readonly readableObjectMode: boolean;\n            destroyed: boolean;\n            constructor(opts?: ReadableOptions);\n            _read(size: number): void;\n            read(size?: number): any;\n            setEncoding(encoding: string): this;\n            pause(): this;\n            resume(): this;\n            isPaused(): boolean;\n            unpipe(destination?: NodeJS.WritableStream): this;\n            unshift(chunk: any, encoding?: BufferEncoding): void;\n            wrap(oldStream: NodeJS.ReadableStream): this;\n            push(chunk: any, encoding?: string): boolean;\n            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. data\n             * 3. end\n             * 4. error\n             * 5. pause\n             * 6. readable\n             * 7. resume\n             */\n            addListener(event: "close", listener: () => void): this;\n            addListener(event: "data", listener: (chunk: any) => void): this;\n            addListener(event: "end", listener: () => void): this;\n            addListener(event: "error", listener: (err: Error) => void): this;\n            addListener(event: "pause", listener: () => void): this;\n            addListener(event: "readable", listener: () => void): this;\n            addListener(event: "resume", listener: () => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: "close"): boolean;\n            emit(event: "data", chunk: any): boolean;\n            emit(event: "end"): boolean;\n            emit(event: "error", err: Error): boolean;\n            emit(event: "pause"): boolean;\n            emit(event: "readable"): boolean;\n            emit(event: "resume"): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: "close", listener: () => void): this;\n            on(event: "data", listener: (chunk: any) => void): this;\n            on(event: "end", listener: () => void): this;\n            on(event: "error", listener: (err: Error) => void): this;\n            on(event: "pause", listener: () => void): this;\n            on(event: "readable", listener: () => void): this;\n            on(event: "resume", listener: () => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: "close", listener: () => void): this;\n            once(event: "data", listener: (chunk: any) => void): this;\n            once(event: "end", listener: () => void): this;\n            once(event: "error", listener: (err: Error) => void): this;\n            once(event: "pause", listener: () => void): this;\n            once(event: "readable", listener: () => void): this;\n            once(event: "resume", listener: () => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: "close", listener: () => void): this;\n            prependListener(event: "data", listener: (chunk: any) => void): this;\n            prependListener(event: "end", listener: () => void): this;\n            prependListener(event: "error", listener: (err: Error) => void): this;\n            prependListener(event: "pause", listener: () => void): this;\n            prependListener(event: "readable", listener: () => void): this;\n            prependListener(event: "resume", listener: () => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: "close", listener: () => void): this;\n            prependOnceListener(event: "data", listener: (chunk: any) => void): this;\n            prependOnceListener(event: "end", listener: () => void): this;\n            prependOnceListener(event: "error", listener: (err: Error) => void): this;\n            prependOnceListener(event: "pause", listener: () => void): this;\n            prependOnceListener(event: "readable", listener: () => void): this;\n            prependOnceListener(event: "resume", listener: () => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: "close", listener: () => void): this;\n            removeListener(event: "data", listener: (chunk: any) => void): this;\n            removeListener(event: "end", listener: () => void): this;\n            removeListener(event: "error", listener: (err: Error) => void): this;\n            removeListener(event: "pause", listener: () => void): this;\n            removeListener(event: "readable", listener: () => void): this;\n            removeListener(event: "resume", listener: () => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n        }\n\n        interface WritableOptions {\n            highWaterMark?: number;\n            decodeStrings?: boolean;\n            defaultEncoding?: string;\n            objectMode?: boolean;\n            emitClose?: boolean;\n            write?(this: Writable, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Writable, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            destroy?(this: Writable, error: Error | null, callback: (error: Error | null) => void): void;\n            final?(this: Writable, callback: (error?: Error | null) => void): void;\n            autoDestroy?: boolean;\n        }\n\n        class Writable extends Stream implements NodeJS.WritableStream {\n            readonly writable: boolean;\n            readonly writableEnded: boolean;\n            readonly writableFinished: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            readonly writableObjectMode: boolean;\n            readonly writableCorked: number;\n            destroyed: boolean;\n            constructor(opts?: WritableOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. drain\n             * 3. error\n             * 4. finish\n             * 5. pipe\n             * 6. unpipe\n             */\n            addListener(event: "close", listener: () => void): this;\n            addListener(event: "drain", listener: () => void): this;\n            addListener(event: "error", listener: (err: Error) => void): this;\n            addListener(event: "finish", listener: () => void): this;\n            addListener(event: "pipe", listener: (src: Readable) => void): this;\n            addListener(event: "unpipe", listener: (src: Readable) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: "close"): boolean;\n            emit(event: "drain"): boolean;\n            emit(event: "error", err: Error): boolean;\n            emit(event: "finish"): boolean;\n            emit(event: "pipe", src: Readable): boolean;\n            emit(event: "unpipe", src: Readable): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: "close", listener: () => void): this;\n            on(event: "drain", listener: () => void): this;\n            on(event: "error", listener: (err: Error) => void): this;\n            on(event: "finish", listener: () => void): this;\n            on(event: "pipe", listener: (src: Readable) => void): this;\n            on(event: "unpipe", listener: (src: Readable) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: "close", listener: () => void): this;\n            once(event: "drain", listener: () => void): this;\n            once(event: "error", listener: (err: Error) => void): this;\n            once(event: "finish", listener: () => void): this;\n            once(event: "pipe", listener: (src: Readable) => void): this;\n            once(event: "unpipe", listener: (src: Readable) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: "close", listener: () => void): this;\n            prependListener(event: "drain", listener: () => void): this;\n            prependListener(event: "error", listener: (err: Error) => void): this;\n            prependListener(event: "finish", listener: () => void): this;\n            prependListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: "close", listener: () => void): this;\n            prependOnceListener(event: "drain", listener: () => void): this;\n            prependOnceListener(event: "error", listener: (err: Error) => void): this;\n            prependOnceListener(event: "finish", listener: () => void): this;\n            prependOnceListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: "close", listener: () => void): this;\n            removeListener(event: "drain", listener: () => void): this;\n            removeListener(event: "error", listener: (err: Error) => void): this;\n            removeListener(event: "finish", listener: () => void): this;\n            removeListener(event: "pipe", listener: (src: Readable) => void): this;\n            removeListener(event: "unpipe", listener: (src: Readable) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        }\n\n        interface DuplexOptions extends ReadableOptions, WritableOptions {\n            allowHalfOpen?: boolean;\n            readableObjectMode?: boolean;\n            writableObjectMode?: boolean;\n            readableHighWaterMark?: number;\n            writableHighWaterMark?: number;\n            writableCorked?: number;\n            read?(this: Duplex, size: number): void;\n            write?(this: Duplex, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Duplex, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Duplex, callback: (error?: Error | null) => void): void;\n            destroy?(this: Duplex, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        // Note: Duplex extends both Readable and Writable.\n        class Duplex extends Readable implements Writable {\n            readonly writable: boolean;\n            readonly writableEnded: boolean;\n            readonly writableFinished: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            readonly writableObjectMode: boolean;\n            readonly writableCorked: number;\n            constructor(opts?: DuplexOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n        }\n\n        type TransformCallback = (error?: Error | null, data?: any) => void;\n\n        interface TransformOptions extends DuplexOptions {\n            read?(this: Transform, size: number): void;\n            write?(this: Transform, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Transform, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Transform, callback: (error?: Error | null) => void): void;\n            destroy?(this: Transform, error: Error | null, callback: (error: Error | null) => void): void;\n            transform?(this: Transform, chunk: any, encoding: string, callback: TransformCallback): void;\n            flush?(this: Transform, callback: TransformCallback): void;\n        }\n\n        class Transform extends Duplex {\n            constructor(opts?: TransformOptions);\n            _transform(chunk: any, encoding: string, callback: TransformCallback): void;\n            _flush(callback: TransformCallback): void;\n        }\n\n        class PassThrough extends Transform { }\n\n        interface FinishedOptions {\n            error?: boolean;\n            readable?: boolean;\n            writable?: boolean;\n        }\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, options: FinishedOptions, callback: (err?: NodeJS.ErrnoException | null) => void): () => void;\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, callback: (err?: NodeJS.ErrnoException | null) => void): () => void;\n        namespace finished {\n            function __promisify__(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, options?: FinishedOptions): Promise<void>;\n        }\n\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: T, callback?: (err: NodeJS.ErrnoException | null) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: T, callback?: (err: NodeJS.ErrnoException | null) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: T,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: NodeJS.ReadWriteStream,\n            stream5: T,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): T;\n        function pipeline(\n            streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): NodeJS.WritableStream;\n        function pipeline(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n            ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException | null) => void)>,\n        ): NodeJS.WritableStream;\n        namespace pipeline {\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.ReadWriteStream, stream4: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream,\n                stream3: NodeJS.ReadWriteStream,\n                stream4: NodeJS.ReadWriteStream,\n                stream5: NodeJS.WritableStream,\n            ): Promise<void>;\n            function __promisify__(streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream>,\n            ): Promise<void>;\n        }\n\n        interface Pipe {\n            close(): void;\n            hasRef(): boolean;\n            ref(): void;\n            unref(): void;\n        }\n    }\n\n    export = internal;\n}'};function W(e){const n=function(n){let t=n.language,i=E()(n,["language"]);const o=Object(s.useRef)([]);return Object(s.useEffect)(()=>{if(["typescript"].includes(t)){const e=o.current;Object.keys(M).forEach(n=>{const t=M[n];e.push(d.languages.typescript.typescriptDefaults.addExtraLib(t,n))})}return()=>{o.current.forEach(e=>e.dispose()),o.current=[]}},[t]),l.a.createElement(e,S()({},i,{language:t}))};return n.displayName=`withExtraLibs(${Object(F.a)(e)})`,n}var J=W,H=t("50DI"),G=t.n(H),z=t("OEX3"),V=t("Gu5L"),q=t("xRcV");function K(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function Y(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?K(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):K(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}const $=e=>{const n=Y({},e.innerProps,{role:"option","aria-disabled":e.isDisabled});return l.a.createElement(q.z.Option,S()({},e,{innerProps:n}))},X=e=>{const n=Y({},e.innerProps,{id:e.selectProps.menuId,role:"listbox","aria-expanded":!0});return l.a.createElement(q.z.MenuList,S()({},e,{innerProps:n}))},Q=e=>{const n=Y({},e,{role:e.selectProps.isSearchable?"combobox":"listbox","aria-owns":e.selectProps.menuId,"aria-autocomplete":"list"});return l.a.createElement(q.z.Input,n)};var Z=function(e){return l.a.createElement(V.e,S()({components:{Option:$,MenuList:X,Input:Q}},e))};t("cojC");function ee(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function ne(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?ee(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ee(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function te(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const t=e||B.default;return(n&&n.length?n:Object.keys(t)).map(e=>({label:t[e].label,value:e}))}const ie=Object(u.b)(P,J)(v);function oe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=arguments.length>1?arguments[1]:void 0,t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=Object(u.a)(ne({},n,{isReadonlyEditable:t})),o=te(i,n?n.languages:null),r=o.find(n=>n.value===e);return{language:r,languages:o,languageOptions:i}}class re extends l.a.Component{constructor(){super(...arguments),a()(this,"state",{}),a()(this,"editor",void 0),a()(this,"setLanguage",e=>{if(!e||Array.isArray(e))return;const n=this.state.language,t=this.props.onLanguageChange,i=e.value;n&&n.value===i||t(i,n.value)}),a()(this,"editorDidMount",e=>{this.editor=e;const n=this.props.editorDidMount;n&&n(e)}),a()(this,"onCodeFold",()=>{this.setState({renderLoading:!1})}),a()(this,"onLspWebsocketChange",e=>{const n=this.state.lspState,t=this.props,i=t.enableAutoComplete,o=t.onLspWebsocketChange;if(!i)return void o(e);const r=Object(u.g)(n,e);r&&r!==n&&this.setState({lspState:r}),o(e)})}static getDerivedStateFromProps(e,n){if(!n||!n.language){const n=oe(e.defaultLanguage,e.languageOptions,e.isReadonlyEditable);return n.lspState=Object(u.d)(n.language,e.enableAutoComplete,e.lspDisabledLanguages),n.prevAutoComplete=e.enableAutoComplete,n.originalLangOptions=e.languageOptions,n.renderLoading=!0,n.previousLangFromProps=e.defaultLanguage,n}if(e.defaultLanguage!==n.previousLangFromProps||e.languageOptions!==n.originalLangOptions){const t=oe(e.defaultLanguage,e.languageOptions,e.isReadonlyEditable);return e.defaultLanguage!==n.previousLangFromProps&&(t.lspState=Object(u.d)(t.language,e.enableAutoComplete,e.lspDisabledLanguages)),t.prevAutoComplete=e.enableAutoComplete,t.originalLangOptions=e.languageOptions,t.previousLangFromProps=e.defaultLanguage,t.renderLoading=!(e.defaultLanguage===n.previousLangFromProps),t}return e.enableAutoComplete!==n.prevAutoComplete?(n.lspState=Object(u.d)(n.language,e.enableAutoComplete,e.lspDisabledLanguages),n.prevAutoComplete=e.enableAutoComplete,n):n}componentDidUpdate(e){!this.props.hideEditor&&e.hideEditor&&this.editor&&this.editor.layout()}renderToolbarItems(e){const n=this.props[e];return n&&n.length?l.a.createElement("div",{className:"toolbar-custom-items"},n.map(e=>{if("string"!=typeof e.type)return e.type;const n=e.attrs||{};return l.a.createElement(z.f,S()({key:e.label},n,{className:e.classList,tabIndex:"0",onClick:e.callback,ariaRole:e.type}),e.label||e.text)})):null}renderEditor(){const e=this.state,n=e.language,t=e.languageOptions,i=e.renderLoading,o=this.props,r=o.hideEditor,a=(o.defaultLanguage,o.languageOptions,o.customToolBar,o.toolbarLeftItems,o.itemsBeforeLanguageSelector,o.toolbarStatus,o.languageSelectClassName,o.renderSettings,o.renderBeforeEditor,o.renderAfterEditor,o.loaderComponent,o.loaderProps,o.showPane,o.languageSelectStyles,o.languageOnLeft,o.autoCompleteClassName,o.showAutocompleteStatus,o.t,E()(o,["hideEditor","defaultLanguage","languageOptions","customToolBar","toolbarLeftItems","itemsBeforeLanguageSelector","toolbarStatus","languageSelectClassName","renderSettings","renderBeforeEditor","renderAfterEditor","loaderComponent","loaderProps","showPane","languageSelectStyles","languageOnLeft","autoCompleteClassName","showAutocompleteStatus","t"])),s=t[n.value],d="hr-monaco-editor-parent"+(r||i?" hr-monaco-editor-hide":"");return l.a.createElement("div",{className:d},l.a.createElement(ie,S()({},a,{language:n.value,syntax:s.syntax||"",code:s,lspEndpoint:s.lsp,fileExtension:s.extension,editorDidMount:this.editorDidMount,onCodeFold:this.onCodeFold,onLspWebsocketChange:this.onLspWebsocketChange})))}renderLoadingDiv(){const e=this.props,n=e.loaderComponent,t=e.loaderProps;return l.a.createElement("div",{className:"hr-monaco-loading-language",style:{height:this.props.height,width:this.props.width}},n?l.a.createElement(n,t):l.a.createElement("p",null,l.a.createElement("span",{className:"hr-monaco-loading-text"}," Loading Code ")))}renderLanguageSelector(){const e=this.state,n=e.language,t=e.languages,i=this.props,o=i.languageSelectClassName,r=i.languageSelectStyles,a=i.t,d=o+" select-language";return n&&1===t.length?l.a.createElement("span",{className:d},l.a.createElement("span",{className:"select-language__label"},a("language"),": "),n.label):l.a.createElement(s.Fragment,null,l.a.createElement("label",{className:"select-language__label",id:"select-language-label",htmlFor:"select-language-input","aria-label":a("select_your_coding_language")},a("language")),l.a.createElement(Z,{className:d,value:n,options:t,onChange:this.setLanguage,isClearable:!1,styles:r,isDisabled:!n||t.length<=1,inputId:"select-language-input","aria-labelledby":"select-language-label",menuId:"select-language-menu"}))}renderAutoCompleteStatus(){const e=this.state,n=e.language,t=e.lspState,i=this.props,o=i.autoCompleteClassName,r=i.showAutocompleteStatus,a=i.loaderComponent,s=i.t;return l.a.createElement(U,{status:t,language:n.label,className:o,loaderComponent:a,showAutocompleteStatus:r,t:s})}render(){const e=this.state.renderLoading,n=this.props,t=n.renderSettings,i=n.renderBeforeEditor,o=n.renderAfterEditor,r=n.toolbarStatus,a=n.languageOnLeft,s=n.showAutocompleteStatus,d=this.renderLanguageSelector();return l.a.createElement("div",{className:"hr-monaco-editor"},l.a.createElement("div",{className:"editor-toolbar"},l.a.createElement("div",{className:"toolbar-left"},a&&d,s&&this.renderAutoCompleteStatus(),r&&l.a.createElement("div",null,r),this.renderToolbarItems("toolbarLeftItems")),l.a.createElement("div",{className:"toolbar-right"},this.renderToolbarItems("itemsBeforeLanguageSelector"),!a&&d,this.renderToolbarItems("customToolBar"),t&&t())),i&&i(),this.renderEditor(),e&&this.renderLoadingDiv(),o&&o())}}a()(re,"defaultProps",{showPane:!1,languageOptions:null,customToolBar:[],toolbarLeftItems:[],itemsBeforeLanguageSelector:[],toolbarStatus:"",hideEditor:!1,height:500,languageSelectClassName:"",renderSettings:p.a,editorDidMount:p.a,onLanguageChange:p.a,renderBeforeEditor:p.a,renderAfterEditor:p.a,loaderComponent:null,loaderProps:{},languageSelectStyles:{},languageOnLeft:!1,showAutocompleteStatus:!1,lspDisabledLanguages:[],onLspWebsocketChange:p.a,t:G.a});var ae=re,se=(t("a1Th"),t("TSYQ")),le=t.n(se),de=t("YqDo"),ce=t("iiin");class pe extends s.PureComponent{constructor(){super(...arguments),a()(this,"onClick",()=>{const e=this.props,n=e.setting,t=e.item;(0,e.onSelect)(n.id,t.value)})}render(){const e=this.props,n=e.value,t=e.item,i=e.setting,o=n===t.value,r=le()("settings-button",{"ui-btn-primary ":o,"ui-btn-default":!o});return l.a.createElement(z.h,{key:t.label,ariaRole:"radio","aria-checked":o,tabIndex:o?"0":"-1",className:r,onClick:this.onClick,"aria-label":`${t.label} ${i.label}`},t.label)}}const ue=-1,fe=1,he=Math.pow(2,24);var me=e=>{var n,t;return t=n=class extends s.PureComponent{constructor(e){super(e),a()(this,"id",void 0),a()(this,"deprecationWarned",!1),a()(this,"editor",void 0),a()(this,"container",void 0),a()(this,"containerRefCb",void 0),a()(this,"editorDidMount",e=>{this.editor=e,this.props.editorDidMount(e)}),a()(this,"containerRefCb",e=>{this.container=e}),a()(this,"onSelectSetting",(e,n)=>{const t=this.state[e];t!==n&&this.setState({[e]:n},()=>{this.props.onChangeSettings(e,n,t)})}),a()(this,"toggleSettingsPane",()=>{this.setState({showPane:!this.state.showPane},()=>{const e=this.props.onToggleSettingsPane,n=this.state.showPane;e(n),n?this.addListeners():(this.removeListeners(),this.container.querySelector(".settings-toggle").focus())})}),a()(this,"handleKeyNav",e=>{if(this.state.showPane&&this.container)if(e.which!==I.b.ESC)if(e.which===I.b.TAB){const n=this.container.querySelectorAll('[tabIndex="0"]');e.target===n[n.length-1]&&n[0].focus()}else e.which===I.b.UP||e.which===I.b.LEFT?this.moveButtonFocus(e,ue):e.which!==I.b.DOWN&&e.which!==I.b.RIGHT||this.moveButtonFocus(e,fe);else this.toggleSettingsPane()}),a()(this,"handleClickOutSide",e=>{const n=this.container;n&&!n.contains(e.target)&&this.toggleSettingsPane()}),a()(this,"renderSettings",()=>{const e=this.state.showPane,n=le()("settings-toggle",{"settings-toggle--active":e});return l.a.createElement("div",{ref:this.containerRefCb,className:"hr-monaco-settings-editor"},l.a.createElement(ce.a,{Icon:de.a,btnText:"More",tabIndex:"0",className:n,onClick:this.toggleSettingsPane,"aria-haspopup":"true","aria-expanded":e,"aria-label":"Editor Settings",title:"Editor Settings",tooltip:!1}),this.renderPane())});const n=e.theme,t=e.tabSize,i=e.mode,o=e.enableAutoComplete,r=e.defaultLanguage,s=e.useRandomId;this.id="kj-editor-"+(s?Math.floor(Math.random()*he).toString(32):""),this.state={theme:n,prevTheme:n,tabSize:t,intellisense:o,mode:i,showPane:!1,currentLanguage:r}}static getDerivedStateFromProps(e,n){return e.theme===n.prevTheme?null:{theme:e.theme,prevTheme:e.theme}}componentWillUnmount(){this.removeListeners()}getIntellisenseTooltipText(){const e=this.props,n=e.lspDisabledLanguages,t=e.t,i=B.LSP_LANGUAGES.filter(e=>n.indexOf(e)<0).map(e=>B.default[e].label).join(", ");return`${Object(u.f)("autocompleteAvailableText",t)} ${i}`}focus(){this.editor&&this.editor.focus()}moveButtonFocus(e,n){let t;const i=e.target.parentElement.children;t=n===fe?e.target===i[i.length-1]?i[0]:e.target.nextSibling:e.target===i[0]?i[i.length-1]:e.target.previousSibling,t&&(e.preventDefault(),t.focus())}removeListeners(){window.removeEventListener("click",this.handleClickOutSide),window.removeEventListener("keydown",this.handleKeyNav)}addListeners(){window.addEventListener("click",this.handleClickOutSide),window.addEventListener("keydown",this.handleKeyNav)}renderCustomSettings(){const e=this.props.renderCustomSettings;return"function"!=typeof e?null:l.a.createElement("div",{className:"formgroup horizontal"},e())}getCustomSettingsContent(){this.deprecationWarned||(console.warn("Deprecation Warning: customSetting prop is deprecated, use renderCustomSetting prop"),this.deprecationWarned=!0);const e=this.props.customSetting;return e.length?l.a.createElement("div",null,e.map((e,n)=>{let t=e.text,i=e.label,o=e.type,r=e.classList,a=e.callback,s=E()(e,["text","label","type","classList","callback"]);const d="link"===o?"a":o;return l.a.createElement("div",{key:n,className:"formgroup horizontal"},i&&l.a.createElement("label",{className:"hr-monaco-formgroup-label"},i),l.a.createElement(d,S()({tabIndex:"0",className:r,onClick:a},s),t))})):null}renderSetting(e){const n=this.props,t=n.showTheme,i=n.showModes,o=n.showIntellisense,r=n.lspDisabledLanguages,a=n.defaultLanguage;if(I.f.THEME===e.id&&!t)return null;if(I.f.EDITOR_MODE===e.id&&!i)return null;if(I.f.AUTOCOMPLETE===e.id&&(!o||!B.LSP_LANGUAGES.includes(a)||r.includes(a)))return null;const s=`${this.id}-${e.id}`,d=this.state[e.id],c=I.f.AUTOCOMPLETE===e.id,p=c?this.getIntellisenseTooltipText():"";return l.a.createElement("div",{key:e.id,"data-automation":`krakjack-${e.id}-setting`,className:"formgroup horizontal",role:"radiogroup","aria-labelledby":s},l.a.createElement("label",{className:"hr-monaco-formgroup-label ",id:s},e.label,c&&l.a.createElement(N.a,{content:p,align:"bottom","data-automation":"autocomplete-tooltip"},l.a.createElement(_.a,{tabIndex:0,"aria-label":"Info icon",role:"button"}))),l.a.createElement("div",{className:"inline"},l.a.createElement("div",{className:"ui-btn-group"},e.items.map(n=>l.a.createElement(pe,{setting:e,value:d,key:n.value,item:n,role:"radio",onSelect:this.onSelectSetting})))))}renderPane(){const e=this.state.showPane,n=this.props,t=n.renderCustomSettings,i=n.t,o=Object(u.i)(i);return e?l.a.createElement("div",{className:"hr-monaco-pref-pane",role:"region"},l.a.createElement("div",{className:"pref-pane-arrow"}),o.map(e=>this.renderSetting(e)),t?this.renderCustomSettings():this.getCustomSettingsContent()):null}render(){const n=this.props,t=(n.mode,n.showModes,n.showIntellisense,n.theme,n.showTheme,n.customSetting,n.onChangeSettings,n.onToggleSettingsPane,n.tabSize,n.defaultLanguage),i=n.lspDisabledLanguages,o=n.enableAutoComplete,r=E()(n,["mode","showModes","showIntellisense","theme","showTheme","customSetting","onChangeSettings","onToggleSettingsPane","tabSize","defaultLanguage","lspDisabledLanguages","enableAutoComplete"]),a=this.state,s=a.theme,d=a.tabSize,c=a.intellisense,p=a.mode,u=a.showPane;let f=!1;return c===o&&!c||i.includes(t)||!B.LSP_LANGUAGES.includes(t)||(f=c),l.a.createElement(e,S()({},r,{defaultLanguage:t,theme:s,tabSize:d,mode:p,enableAutoComplete:f,lspDisabledLanguages:i,showPane:u,renderSettings:this.renderSettings,editorDidMount:this.editorDidMount,intellisense:c}))}},a()(n,"displayName",`withSettings(${Object(u.e)(e)})`),a()(n,"defaultProps",{mode:"normal",showModes:!0,showIntellisense:!0,theme:"light",tabSize:4,enableAutoComplete:!1,showTheme:!0,customSetting:[],editorDidMount:p.a,onChangeSettings:p.a,onToggleSettingsPane:p.a,lspDisabledLanguages:[],useRandomId:!0,SettingsIcon:de.a}),t},ge=(t("fKZA"),e=>{var n,t;return t=n=class extends l.a.Component{constructor(e){super(e),a()(this,"disposable",void 0),a()(this,"input",void 0),a()(this,"cmdInputOptions",void 0),a()(this,"onCmdKeyDown",e=>{const n=this.cmdInputOptions,t=this.cmdInputOnclose;n&&n.onKeyDown&&n.onKeyDown(e,e.target.value,()=>{e.preventDefault(),e.stopPropagation(),this.toggleCommandInput(!1),this.editor.focus()})||((e.keyCode===I.b.ESC||n&&!1!==n.closeOnEnter&&e.keyCode===I.b.ENTER)&&(this.input.blur(),e.preventDefault(),e.stopPropagation(),this.toggleCommandInput(!1),this.editor.focus()),e.keyCode===I.b.ENTER&&t&&t(e.target.value,e))}),a()(this,"onCmdKeyUp",e=>{this.cmdInputOptions&&this.cmdInputOptions.onKeyUp&&this.cmdInputOptions.onKeyUp(e,e.target.value,()=>{this.toggleCommandInput(!1)})}),a()(this,"setStatusMessage",e=>{e!==this.state.statusMessage&&this.setState({statusMessage:e})}),a()(this,"commandInputRef",e=>{this.input=e}),a()(this,"toggleCommandInput",(e,n,t)=>{this.setState({enableCommandInput:e}),this.cmdInputOnclose=n,this.cmdInputOptions=t}),a()(this,"editorDidMount",e=>{const n=this.props.editorDidMount;this.editor=e,n(e),this.setState({position:e.getPosition()}),this.disposable=e.onDidChangeCursorPosition(e=>{let n=e.position;this.setState({position:n})})}),this.state={position:null,statusMessage:e.initialStatusMessage,enableCommandInput:!1}}componentDidUpdate(e,n){const t=this.state.enableCommandInput;n.enableCommandInput!==t&&t&&this.input&&(this.input.focus(),this.cmdInputOptions&&this.cmdInputOptions.selectValueOnOpen&&this.input.select())}componentWillUnmount(){this.disposable&&this.disposable.dispose()}render(){const n=this.props,t=n.enablePositionInfo,i=(n.initialStatusMessage,n.statusBarChildren),o=E()(n,["enablePositionInfo","initialStatusMessage","statusBarChildren"]),r=this.state,a=r.position,s=r.statusMessage,d=r.enableCommandInput;return l.a.createElement("div",{className:"hr-monaco-editor-with-statusbar"},l.a.createElement(e,S()({},o,{editorDidMount:this.editorDidMount,setStatusMessage:this.setStatusMessage,toggleCommandInput:this.toggleCommandInput})),l.a.createElement("div",{className:"hr-monaco-editor-statusbar"},l.a.createElement("div",{style:{display:"flex"}},(s||d)&&l.a.createElement("div",{className:"statusbar-message-container"},l.a.createElement("div",{className:"statusbar-message"},s),d&&l.a.createElement("input",{ref:this.commandInputRef,className:"statusbar-command-input",type:"text",onKeyDown:this.onCmdKeyDown,onKeyUp:this.onCmdKeyUp,defaultValue:""})),i&&l.a.createElement("div",{className:"statusbar-children"},i)),t&&a&&l.a.createElement("div",{className:"statusbar-position"},"Line: ",a.lineNumber," Col: ",a.column)))}},a()(n,"displayName",`withStatusBar(${Object(u.e)(e)})`),a()(n,"defaultProps",{enablePositionInfo:!0,initialStatusMessage:"",editorDidMount:p.a,statusBarChildren:void 0}),t});function be(e){class n extends s.Component{constructor(e){super(e),a()(this,"currentLanguage",void 0),a()(this,"editor",void 0),a()(this,"onCompileTest",e=>{e.persist();(0,this.props.onCompileTest)({language:this.currentLanguage,code:this.editor.getValue()},e)}),a()(this,"onSubmitCode",e=>{e.persist();(0,this.props.onSubmitCode)({language:this.currentLanguage,code:this.editor.getValue()},e)}),a()(this,"onLanguageChange",(e,n)=>{this.currentLanguage=e,this.props.onLanguageChange(e,n)}),a()(this,"editorDidMount",e=>{this.editor=e,this.props.editorDidMount(e)}),this.currentLanguage=e.defaultLanguage}renderButtons(){const e=this.props,n=e.submitButtonProps,t=e.compileButtonProps,i=e.compileButtonText,o=e.submitButtonText,r=e.showSubmit,a=e.showCompileTest,s=e.compileTestBlocked,d=e.submitBlocked;return l.a.createElement("div",{className:"pmR pmL pmB plT run-code-wrapper"},r&&l.a.createElement(z.d,S()({},n,{onClick:this.onSubmitCode,disabled:!!d||void 0,className:"pull-right hr-monaco-submit"}),o),a&&l.a.createElement(z.f,S()({},t,{onClick:this.onCompileTest,disabled:!!s||void 0,className:"pull-right msR hr-monaco-compile hr-monaco__run-code"}),i))}render(){const n=this.props,t=(n.showSubmit,n.showCompileTest,n.compileButtonText,n.submitButtonText,n.onCompileTest,n.onSubmitCode,n.compileTestBlocked,n.submitBlocked,n.submitButtonSubText),i=E()(n,["showSubmit","showCompileTest","compileButtonText","submitButtonText","onCompileTest","onSubmitCode","compileTestBlocked","submitBlocked","submitButtonSubText"]);return l.a.createElement("div",null,l.a.createElement(e,S()({},i,{editorDidMount:this.editorDidMount,onLanguageChange:this.onLanguageChange})),t?l.a.createElement("div",{className:"hr-monaco-btn-wrapper"},this.renderButtons(),l.a.createElement("span",{className:"hr-monaco-sub-text"},t)):this.renderButtons())}}return a()(n,"displayName",`withRunCode(${Object(u.e)(e)})`),a()(n,"defaultProps",{showSubmit:!0,showCompileTest:!0,submitButtonProps:{},compileButtonProps:{},compileButtonText:"Run Code",submitButtonText:"Submit Code",submitButtonSubText:"",onLanguageChange:p.a,editorDidMount:p.a,compileTestBlocked:!1,submitBlocked:!1}),n}var ve=t("1OM/");class ye extends l.a.Component{constructor(e){super(e),a()(this,"input",void 0),a()(this,"inputRefCb",e=>{this.input=e}),a()(this,"onChange",e=>{const n=this.props.onChange,t=e.target.value;n(t);let i="";const o=/^(\s)+/.test(t),r=/(\s)+$/.test(t);o&&r?i="* Leading and trailing spaces detected in custom input":o?i="* Leading spaces detected in custom input":r&&(i="* Trailing spaces detected in custom input"),this.setState({value:t,warningText:i})}),this.state={value:e.defaultValue||"",warningText:""}}componentDidMount(){this.input&&this.input.focus()}getValue(){return this.state.value}render(){const e=this.state,n=e.value,t=e.warningText,i=this.props,o=i.className,r=i.showWarning;return l.a.createElement("div",null,l.a.createElement(ve.b,{type:"textarea",inputRef:this.inputRefCb,className:o,rows:"5",value:n,onChange:this.onChange,autoComplete:"off",autoCorrect:"off",autoCapitalize:"off",spellCheck:"false"}),r&&t&&l.a.createElement("span",{className:"block hr-monaco-input-warning"},t))}}a()(ye,"defaultProps",{defaultValue:"",className:"",showWarning:!1,onChange:p.a});var Se=t("g+WX");function Le(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function Ee(e){class n extends l.a.Component{constructor(e){super(e),a()(this,"onCompileTest",void 0),a()(this,"onSubmitCode",void 0),a()(this,"inputRef",void 0),a()(this,"inputRefCb",e=>{this.inputRef=e}),a()(this,"onInputChange",e=>{this.setState({input:e});const n=this.props.inputProps;n.onChange&&n.onChange(e)}),a()(this,"toggleInput",e=>{this.setState({showInput:e.target.checked}),this.props.onCheckboxToggle(e)}),this.state={input:"",showInput:!1},this.onCompileTest=this.addInputToCallback.bind(this,"onCompileTest"),this.onSubmitCode=this.addInputToCallback.bind(this,"onSubmitCode")}addInputToCallback(e,n,t){const i=this.props[e];let o=n;this.state.showInput&&(o=function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?Le(Object(t),!0).forEach((function(n){a()(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):Le(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}({},o,{custominput:this.inputRef.getValue()})),i(o,t)}render(){const n=this.state.showInput,t=this.props,i=(t.onCheckboxToggle,t.CheckBoxComponent,t.InputComponent),o=t.inputProps,r=t.customInputWrapperClass,a=t.showStraySpaceWarning,s=t.onUploadClick,d=t.showCustomInput,c=t.showUploadCode,p=E()(t,["onCheckboxToggle","CheckBoxComponent","InputComponent","inputProps","customInputWrapperClass","showStraySpaceWarning","onUploadClick","showCustomInput","showUploadCode"]),u=d||c;return l.a.createElement("div",{className:"hr-monaco-editor-with-input"},l.a.createElement(e,S()({},p,{onCompileTest:this.onCompileTest,onSubmitCode:this.onSubmitCode})),u&&l.a.createElement("div",{className:"pmR pmL pmB hr-monaco-custom-input-wrapper "+r},c&&l.a.createElement("div",null,l.a.createElement(z.f,{className:"upload-file mlR","data-analytics":"Upload File",type:"button",onClick:s},l.a.createElement("i",{className:"icon-upload ui-icon-upload"}),"Upload Code as File")),d&&l.a.createElement("div",{className:"checkBoxWrapper"},l.a.createElement(Se.a,{label:"Test against custom input",checked:n,onChange:this.toggleInput}),n&&l.a.createElement(i,S()({ref:this.inputRefCb},o,{onChange:this.onInputChange,showWarning:a,className:"custominput auto-width"})))))}}return a()(n,"displayName",`withInput(${Object(u.e)(e)})`),a()(n,"defaultProps",{inputProps:{defaultValue:""},onUploadClick:p.a,onCheckboxToggle:p.a,onCompileTest:p.a,onSubmitCode:p.a,CheckBoxComponent:Se.a,InputComponent:ye,showCustomInput:!0,showUploadCode:!0,customInputWrapperClass:"flex",showStraySpaceWarning:!0}),n}t("OG14");var ke=e=>{var n,i;return i=n=class extends s.PureComponent{constructor(){super(...arguments),a()(this,"editor",void 0),a()(this,"keyBuffer",void 0),a()(this,"currentMacro",void 0),a()(this,"currentMode",void 0),a()(this,"vimMode",void 0),a()(this,"emacsMode",void 0),a()(this,"isRecording",void 0),a()(this,"disposable",void 0),a()(this,"editorDidMount",e=>{this.editor=e,this.setMode(this.props.mode),this.props.editorDidMount(e)})}componentDidUpdate(e){e.mode!==this.props.mode&&this.setMode(this.props.mode)}componentWillUnmount(){this.unbindModes()}unbindModes(){this.vimMode&&(this.vimMode.dispose(),this.vimMode=null,this.keyBuffer="",this.currentMacro="",this.currentMode="",this.props.setStatusMessage(""),this.props.toggleCommandInput(!1)),this.emacsMode&&(this.emacsMode.dispose(),this.emacsMode=null,this.props.setStatusMessage(""))}setMode(e){this.unbindModes(),this.keyBuffer="",this.currentMacro="",this.currentMode="","vim"===e?t.e(297).then(t.t.bind(null,"iH6r",7)).then(n=>{const t=n.VimMode;this.addExtension(t),this.vimMode=new t(this.editor),this.addListeners(this.vimMode),this.vimMode&&(this.vimMode.attach(),this.props.onMountMode(e,this.vimMode,n))}):"emacs"===e?t.e(296).then(t.t.bind(null,"VrTg",7)).then(n=>{const t=new(0,n.EmacsExtension)(this.editor);t.onDidMarkChange(e=>{this.props.setStatusMessage(e?"Mark Set!":"Mark Unset")}),t.onDidChangeKey(e=>{this.props.setStatusMessage(e||"EMACS")}),this.props.setStatusMessage("EMACS"),t.start(),this.emacsMode=t,this.props.onMountMode(e,t,n)}):this.props.onMountMode(e)}addExtension(e){e.defineExtension("openDialog",(e,n,t)=>{if(e.includes("recording")){const n=/\[([a-zA-Z0-9])\]/,t=e.search(n);if(!(t>-1))return void(this.currentMacro="");this.currentMacro=e[t+1],this.isRecording=!0,this.updateStatusBar()}else e.includes("<input")&&(this.props.setStatusMessage(e.includes("regex")?"/":":"),this.props.toggleCommandInput(!0,n,t))}),e.defineExtension("closeDialog",()=>{this.keyBuffer=""})}updateStatusBar(){const e=this.props.setStatusMessage;let n=`--${this.currentMode}--`;this.keyBuffer&&(n+=" , "+this.keyBuffer),this.currentMacro&&(n+=` , [recording](${this.currentMacro})`),e(n)}addAction(){this.editor&&(this.disposable=this.editor.addAction({id:"extension.vim",label:"Toggle VIM Mode",run:()=>{this.vimMode?(this.vimMode.dispose(),this.props.setStatusMessage(""),this.props.toggleCommandInput(!1)):this.setMode(this.props.mode)}}))}removeAction(){this.disposable&&this.disposable.dispose()}addListeners(e){this.currentMode="",e.on("vim-mode-change",e=>{"object"==typeof e&&e.mode&&(this.currentMode=e.mode.toUpperCase(),this.updateStatusBar())}),e.on("vim-keypress",e=>{"string"==typeof e&&(this.keyBuffer+=e,"q"===e&&this.isRecording&&(this.currentMacro="",this.keyBuffer="",this.isRecording=!1),this.updateStatusBar())}),e.on("vim-command-done",()=>{this.keyBuffer="",this.updateStatusBar()})}render(){const n=this.props,t=(n.mode,n.toggleCommandInput,E()(n,["mode","toggleCommandInput"]));return l.a.createElement(e,S()({},t,{editorDidMount:this.editorDidMount}))}},a()(n,"displayName",`withModes(${Object(u.e)(e)})`),a()(n,"defaultProps",{mode:"normal",editorDidMount:p.a,setStatusMessage:p.a,toggleCommandInput:p.a,onMountMode:p.a}),i},xe=t("DzJC"),Ie=t.n(xe),Te=e=>{var n,t;return t=n=class extends s.PureComponent{constructor(e){var n;super(e),n=this,a()(this,"callBacks",void 0),a()(this,"currentLanguage",void 0),a()(this,"totalCharsTyped",void 0),a()(this,"editor",void 0),a()(this,"focusLogged",void 0),a()(this,"suggestionEnabled",void 0),a()(this,"disposables",void 0),a()(this,"throttledCompletion",void 0),a()(this,"popupOpened",void 0),a()(this,"completionEvents",void 0),a()(this,"editorDidMount",e=>{this.props.editorDidMount(e),this.editor=e,this.attachEditorEvents()}),a()(this,"onAnalytics",(function(e,t,i){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;const s={event_type:e,event_name:t};void 0!==i&&(s.event_value=i),void 0!==o&&(s.integer_event_value=o),r&&(s.metadata=r),n.props.onAnalytics(s,a)})),a()(this,"onCompletionReceive",e=>{this.completionEvents.push(e),this.throttledCompletion(),this.props.onCompletionReceive(e)}),a()(this,"reduceCompletionEvents",()=>{const e=this.completionEvents;if(!e.length)return;const n=e.reduce((e,n)=>(e.timeTaken+=n.timeTaken,e.totalItems+=n.totalItems,e),{timeTaken:0,totalItems:0}),t=e.map(e=>({startTime:e.startTime,timeTaken:e.timeTaken}));this.onAnalytics("Completion","KrackJackCompletionReceive",void 0,void 0,{averageTimeTaken:n.timeTaken/e.length,averageItems:n.totalItems/e.length,currentTime:Date.now(),eventCount:e.length,language:this.currentLanguage},{eventTimes:t}),this.completionEvents=[]}),a()(this,"onLanguageChange",(e,n)=>{const t=this.props,i=t.onLanguageChange,o=t.languageOptions;this.currentLanguage=e,this.completionEvents=[],i(e,n),o.languages.includes(e)?this.onAnalytics("change","KrackJackChangeLanguage",this.currentLanguage):this.onAnalytics("change","KrackJackChangeLanguageError",this.currentLanguage,void 0,{availableLangugages:o.languages,oldLanguage:n}),this.setInitialData()}),a()(this,"onKeyDown",e=>{if(this.totalCharsTyped+=1,!this.suggestionEnabled)return void this.attachSuggestionEvents();if(e.keyCode!==d.KeyCode.Enter)return;const n=this.editor.getContribution("editor.contrib.suggestController")._widget.getValue();if(!n||!n.suggestWidgetVisible.get())return;const t=n.getDomNode(),i=t.querySelectorAll(".monaco-list-row").length,o=t.querySelector(".monaco-list-row.focused");o&&this.onAnalytics("change","KrackJackAutoCompleteSelect",void 0,void 0,{currentTotal:i,index:parseInt(o.dataset.index,10)})}),a()(this,"onFocus",()=>{this.focusLogged||(this.focusLogged=!0,this.onAnalytics("focus","KrackJackUserIsInsideTheEditor",this.currentLanguage))}),a()(this,"onSubmitCode",(e,n)=>{(0,this.props.onSubmitCode)(e,n),this.onAnalytics("change","KrackJackTotalCharactersTypedBeforeSubmit",this.totalCharsTyped)}),a()(this,"onToggleSettingsPane",e=>{(0,this.props.onToggleSettingsPane)(e),this.onAnalytics("Click","KrackJackShowPreferences",e?"Opened":"Closed")}),a()(this,"onShowSuggestion",()=>{this.popupOpened||(this.popupOpened=!0,this.onAnalytics("change","KrackJackAutoCompletePopUp","shown"))}),a()(this,"onHideSuggestion",()=>{this.popupOpened&&(this.popupOpened=!1,this.onAnalytics("change","KrackJackAutoCompletePopUp","closed"))}),a()(this,"onSelectSuggestion",e=>{this.onAnalytics("change","KrackJackAutoCompleteSelect",void 0,void 0,{currentTotal:e.model.items.length,index:e.index})}),a()(this,"onChangeSettings",(e,n,t)=>{(0,this.props.onChangeSettings)(e,n,t);let i=e,o=n;switch(e){case"theme":i="EditorTheme";break;case"tabSize":i="EditorSpace",o=""+n;break;case"mode":i="EditorMode",o=n[0].toUpperCase()+n.substring(1);break;case"intellisense":i="AutoComplete",o=n?"on":"off"}this.onAnalytics("Click","KrackJack"+i,o)}),a()(this,"onPaste",(e,n)=>{this.props.onPaste(e,n),this.onAnalytics("Change","KrackJackPaste",n.length)}),a()(this,"onReadonlyType",()=>{this.onAnalytics("Change","KrackJackReadonlyType")}),a()(this,"onLspWebsocketChange",e=>{const n=e.event,t=e.eventData,i=e.language,o={[I.g.CONNECT]:["Connect","LspWebsocketConnect",i],[I.g.RECONNECT]:["Reconnect","LspWebsocketReconnect",i,t.retryCount],[I.g.ERROR]:["Error","LspWebsocketConnectError",i],[I.g.CLOSE]:["Close","LspWebsocketClose",i],[I.c.CONNECT]:["Connect","LspClientConnect",i],[I.c.DISCONNECT]:["Disconnect","LspClientDisconnect",i],[I.c.ERROR]:["Error","LspClientError",i,void 0,t],[I.c.CLOSE]:["Close","LspClientClose",i]};if(Array.isArray(o[n])){const e=o[n];this.onAnalytics(...e)}this.props.onLspWebsocketChange(e)}),this.currentLanguage=e.defaultLanguage||"",this.setInitialData(),this.disposables=[],this.completionEvents=[],this.throttledCompletion=Ie()(this.reduceCompletionEvents,e.completionFuncInterval,{leading:!1,trailing:!0}),this.popupOpened=!1}setInitialData(){this.totalCharsTyped=0,this.focusLogged=!1,this.suggestionEnabled=!1}componentWillUnmount(){this.throttledCompletion.flush(),this.disposables.forEach(e=>e.dispose())}attachEditorEvents(){this.disposables.push(this.editor.onKeyDown(this.onKeyDown)),this.disposables.push(this.editor.onDidFocusEditorText(this.onFocus))}attachSuggestionEvents(){const e=this.editor.getContribution("editor.contrib.suggestController")._widget.getValue();if(!e)return;this.suggestionEnabled=!0;const n=this.disposables;n.push(e.onDidShow(this.onShowSuggestion)),n.push(e.onDidHide(this.onHideSuggestion)),n.push(e.onDidSelect(this.onSelectSuggestion))}render(){const n=this.props,t=(n.completionFuncInterval,n.onAnalytics,E()(n,["completionFuncInterval","onAnalytics"]));return l.a.createElement(e,S()({},t,{editorDidMount:this.editorDidMount,onSubmitCode:this.onSubmitCode,onLanguageChange:this.onLanguageChange,onChangeSettings:this.onChangeSettings,onToggleSettingsPane:this.onToggleSettingsPane,onCompletionReceive:this.onCompletionReceive,onPaste:this.onPaste,onLspWebsocketChange:this.onLspWebsocketChange,onReadonlyType:this.onReadonlyType}))}},a()(n,"displayName",`withMetrics(${Object(u.e)(e)})`),a()(n,"defaultProps",{completionFuncInterval:5e3,editorDidMount:p.a,onAnalytics:p.a,onLanguageChange:p.a,onSubmitCode:p.a,onChangeSettings:p.a,onToggleSettingsPane:p.a,onCompletionReceive:p.a,onPaste:p.a,onLspWebsocketChange:p.a}),t};t.d(n,"Editor",(function(){return we})),t.d(n,"AVAILABLE_LANGUAGES",(function(){return i.AVAILABLE_LANGUAGES})),t.d(n,"registerAllAvailableLanguages",(function(){return o.registerAllAvailableLanguages})),t.d(n,"BaseEditor",(function(){return v})),t.d(n,"withLsp",(function(){return P})),t.d(n,"AutocompleteStatus",(function(){return U})),t.d(n,"generateFullCode",(function(){return u.c})),t.d(n,"hasTemplateChanged",(function(){return u.j})),t.d(n,"revertTemplate",(function(){return f})),t.d(n,"LANGUAGE_OPTIONS",(function(){return B.LANGUAGE_OPTIONS})),t.d(n,"LSP_LANGUAGES",(function(){return B.LSP_LANGUAGES})),t.d(n,"setMonacoEnvironment",(function(){return j.setMonacoEnvironment})),t.d(n,"withExtraLibs",(function(){return W})),t.d(n,"KrackJackEditor",(function(){return ae})),t.d(n,"withSettings",(function(){return me})),t.d(n,"withStatusBar",(function(){return ge})),t.d(n,"withRunCode",(function(){return be})),t.d(n,"withInput",(function(){return Ee})),t.d(n,"withModes",(function(){return ke})),t.d(n,"withAnalytics",(function(){return Te}));const we=Object(u.b)(Te,Ee,be,me,ge,ke)(ae);n.default=we},zhsW:function(e,n,t){"use strict";function i(e){return`importScripts('${e}')`}function o(e){return"data:text/javascript;charset=utf-8,"+encodeURIComponent(i(e))}function r(e){let n;const t=i(e);try{n=new Blob([t],{type:"application/javascript"})}catch(i){try{const e=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder);e.append(t),n=e.getBlob("application/javascript")}catch(n){return o(e)}}try{return(window.URL||window.webkitURL).createObjectURL(n)}catch(n){return o(e)}}t.r(n),t.d(n,"getWorkerURL",(function(){return i})),t.d(n,"getMonacoWorkerDataUri",(function(){return o})),t.d(n,"createWorkerFallbackUri",(function(){return r})),t.d(n,"setMonacoEnvironment",(function(){return a}));const a=function(){let e=!1;return function(n){e||(e=!0,window.MonacoEnvironment={getWorkerUrl:function(e,t){let i;i="editorWorkerService"===t?"editor":"javascript"===t?"typescript":t;const o=n(i+".worker.js");return"/"===o[0]?window.location.origin+o:r(o)}})}}()}}]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/modules~hackerrank_r_krackjack-a7088dc0.js.map